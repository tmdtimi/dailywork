##回溯法 

递归

纯暴力搜索  并不是高效算法 得到所有结果

组合问题 ---有多少种组合

切割问题 ---字符串有多少种切割方式

子集问题  1 2 3 4   12 23 24 14 13 ....

排列问题 

棋盘  n皇后  数独....



**抽象为  树形结构**



void backTracking{
	
if(终止条件){

收集结果
return 
}

for(){}

return
}








### 组合问题


**1234大小为2的排列**
给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合

	class Solution {
    List<List<Integer>> res=new ArrayList<>();
    public List<List<Integer>> combine(int n, int k) {
        Deque<Integer> list=new ArrayDeque<>();
        arr(list,1,n,k);
        return res;
    }


    void arr(Deque<Integer> list,int p,int n,int k){
        if(list.size()==k){
           res.add(new ArrayList<>(list));
           return;
        }else{
            for(int i=p;i<=n;i++){
                list.addLast(i);
                arr(list,i+1,n,k);
                list.removeLast();
            }
        }
    }
	}





**全排列问题**

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

	输入：nums = [1,2,3]
	输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]


	class Solution {
    private List<List<Integer>> res=new ArrayList<>();  
    public List<List<Integer>> permute(int[] nums) {
        
        List<Integer> list=new ArrayList<>();
        for(int num:nums){
            list.add(num);
        }
        perm(0,nums.length-1,list);
        return res;
    }

    public void perm(int p,int q,List<Integer> list){
        if(p==q){
            res.add(new ArrayList<Integer>(list));
        }
        for(int i=p;i<=q;i++){
            Collections.swap(list,p,i);
            perm(p+1,q,list);
            Collections.swap(list,p,i);
        }
    }
	}


