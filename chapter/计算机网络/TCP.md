# TCP #

Transmission Control protocol 传输控制协议

面向连接的  面向字节流  可靠的传输层协议

![](../pics/n1.png)

源端口号 目的端口号 ： 各占两个字节

序号： 占四个字节。 对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。

确认号：占4个字节。 期望收到下一个报文段的序号。 例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。

首部长度： 一个字节。数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。

确认ACK:当ACK=1时，确认号字段有效。否则无效，TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 

同步SYN:在建立连接时用来同步序号。当SYN=1,ACK=0时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。

终止FIN：用来释放一个连接，当FIN=1时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。

窗口： 占两个字节。窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

检验和：占两个字节。 检验和字段检验的范围包括首部和数据这两个部分。在计算检验和时，在TCP报文段的前面加上12字节的伪首部。

套接字： TCP连接的端点叫做套接字或插口。端口号拼接到IP地址即构成了套接字。



##三次握手、四次挥手

**三次握手：**

建立一个TCP连接时，需要客户端和服务段总共发送三个包。来确认双方的接受、发送能力是否正常、指定自己的初始化序列号并为之后的可靠性传送做准备。

连接服务器指定端口，建立TCP连接，并同步双方的序列号和确认号，交换TCP窗口大小信息。

刚开始客户端处于关闭状态，服务器处于Listen状态。

![](../pics/b1.png)

第一次握手：客户端给服务段发送一个 SYN 报文，并指明客户端的初始化序列号。此时客户端处于SYN_SENT状态。

首部的SYN=1 , 初始序号 seq=x 。 SYN=1的报文不能携带数据，但要消耗一个序号。

第二次握手：服务段在收到客户端的SYN报文之后，会为自己的SYN报文作为应答。并且也指定了自己的初始化序列号。

同时将x+1 作为自己的确认号 ack,表示自己已经收到了客户端的SYN,此时服务器处于SYN_RCVD

在确认报文中: SYN=1 ACK=1 seq=y ack=x+1

第三次握手：客户端在收到SYN报文之后，会发送一个ACK报文，将服务器的序号+1作为自己的确认号，表示已收到服务段SYN，此时服务器处于ESTABLISHED状态，此时，双方建立起了连接。

确认报文 ACK=1 seq=x+1 ack=y+1

在socket编程中，客户端执行connect()时，将触发三次握手。


**四次挥手：**

终止一个连接要经过四次挥手，这是由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。

刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：


![](../pics/b2.png)

第一次挥手： 客户端发送一个FIN报文，报文中指定一个序列号。此时客户端处于 FIN_WAIT1状态。

发出释放连接的报文： FIN=1 seq=u 并停止再发送数据，主动关闭TCP连接进入，FIN_WAIT1状态,等待服务段的确认。

第二次挥手： 服务端收到FIN后，会发送ACK报文，且把客户端序号+1作为ACK确认序列值，表明已收到客户端的报文，此时服务器处于CLOSE_WAIT

即服务段收到客户端连接释放请求即发出确认报文段 ACK=1 序号seq=v 确认号ack=u+1 

此时TCP连接处于 半关闭状态。 客户端到服务段的连接释放。 客户端收到服务段的确认报文后，进行FIN_WAIT2状态，等待服务端发出的连接释放。

第三次挥手： 如果服务段也想释放连接，则需要向客户端 发送FIN报文,此时服务段处于LAST_ACK状态

服务端向客户端发出释放连接报文  FIN=1 ACK=1 序号seq=w 确认号ack=u+1 ，服务段进行LAST_ACK状态，等待客户端最终的确认。

第四次挥手，客户端在收到FIN后，发送ACK报文给服务段

ACK=1 seq=u+1 ack=w+1  客户端进入TIME_WAIT状态 ， 此时TCP未释放掉，2MSL后，客户端才进入CLOSED状态。

timewait 2倍报文存活最大时间

为了保证客户端发送的最后一个ack报文段能够到达服务器。因为这最后一个ack确认包可能会丢失，然后服务器就会超时重传第三次挥手的fin信息报，然后客户端再重传一次第四次挥手的ack报文。

如果没有这2msl，客户端发送完最后一个ack数据报后直接关闭连接，那么就接收不到服务器超时重传的fin信息报(此处应该是客户端收到一个非法的报文段，而返回一个RST的数据报，表明拒绝此次通信，然后双方就产生异常，而不是收不到。)，那么服务器就不能按正常步骤进入close状态。那么就会耗费服务器的资源。




**为什么需要三次握手**

需要三次握手才能确认双方的接收与发送能力是否正常。


**为什么需要四次挥手**

因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。

但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。


![](../pics/b3.png)


**重传机制**

可靠传输实现方式之一： 序列号和确认号   seq=100---->   ack=101----->

如果数据在传输过程中丢失了。 TCP针对数据包丢失情况-->重传机制

**超时重传**

当发送报文时，设置一个计时器，当超过指定的时间后，没有收到对方的ack确认应答报文，就会重发该数据。

在以下两种情况会发生超时重传
1. 数据包丢失
2. 确认应答丢失

RTT指从发送报文到接受到确认报文的时间

超时重传时间是以 RTO （Retransmission Timeout 超时重传时间）表示。

![](../pics/b4.png)


超时重传时间 RTO 的值应该略大于报文往返 RTT 的值

因为网络状态是经常变化的，所以RTT也会变化，需要对RTT进行采样，加权平均得出最后的RTO

如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是超时间隔RTO加倍。

如果超时重发的数据，再次超时，又需要重传的时候，都会将下一次超时时间间隔设置为先前值得两倍。两次重复发送就说明网络环境差，不宜频繁发送。

超时重传周期可能相对较长，所以又提出了快速重传的方式。

**快速重传**

快速重传机制不以时间为驱动，而是以数据为驱动

![](../pics/b5.png)

发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。

最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。

快速重传机制只解决了一个问题，就是超时时间的问题，

但是它依然面临着另外一个问题。就是重传的时候，是重传之前的一个，还是重传所有的问题。

---SACK 头部选项中加 SACK 可以确定哪段数据发生丢失

**滑动窗口**

TCP是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。 这样效率太低了。

数据包的往返时间越长，通信的效率就越低。

为解决这个问题，TCP 引入了窗口这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。

有了窗口，就可以指定窗口大小，窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。

窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。

假设窗口大小为 3 个 TCP 段，那么发送方就可以「连续发送」 3 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：

![](../pics/b6.png)

图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫累计确认或者累计应答。

TCP 头里有一个字段叫 Window，也就是窗口大小。

这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。

于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。

通常窗口的大小是由接收方的窗口大小来决定的。

发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。

![](../pics/b7.png)

当发送方把 发送窗口数据全部发送出去后，可用窗口大小就变成0了。 在没有收到ACK确认之前无法继续发送数据了。

在收到5个字节（比如）的ACK应答之后，窗口向右滑5个字节。

TCP通过三个指针来跟踪四个传输类别中每一个类别中的字节。


![](../pics/b8.png)

可用窗口大小=SND.WND-(SND.NXT-SND.UNA)

因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。


**流量控制**

发送端在发送数据时需考虑到接收方的接收处理能力。

如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。

TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。

由于发送窗口和接收窗口并不是不变的，发送窗口和接收窗口存放的字节数，都是存放在操作系统内存缓冲区中的。而操作系统的缓冲区，会被操作系统调整。

TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。

TCP 通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。

如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。

![](../pics/b9.png)

可能产生死锁现象。

为了解决这个问题，TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。

如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。

窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 RST 报文来中断连接。


**拥塞控制**

在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大....

所以TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。

拥塞控制，控制的目的就是避免「发送方」的数据填满整个网络。

为了在「发送方」调节所要发送数据的量，定义了一个叫做「拥塞窗口」的概念。

拥塞窗口 cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。

发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于加入了拥塞窗口的概念后，

此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。

拥塞窗口 cwnd 变化的规则：

只要网络中没有出现拥塞，cwnd 就会增大；
但网络中出现了拥塞，cwnd 就减少；

其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络出现了用拥塞。

拥塞控制主要是四个算法：

慢启动

拥塞避免

拥塞发生

快速恢复


慢启动：TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，如果一上来就发大量的数据，这不是给网络添堵吗？

当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1

![](../pics/a1.png)

有一个叫慢启动门限 ssthresh （slow start threshold）状态变量。

当 cwnd < ssthresh 时，使用慢启动算法。
当 cwnd >= ssthresh 时，就会使用「拥塞避免算法」。

拥塞避免算法：

前面说道，当拥塞窗口 cwnd 「超过」慢启动门限 ssthresh 就会进入拥塞避免算法。

一般来说 ssthresh 的大小是 65535 字节。

那么进入拥塞避免算法后，它的规则是：每当收到一个 ACK 时，cwnd 增加 1/cwnd。

假定 ssthresh 为 8

当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 MSS 大小的数据，变成了线性增长。


![](../pics/a2.png)

所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。

就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。

当触发了重传机制，也就进入了「拥塞发生算法」。

拥塞发生：

当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：

超时重传
快速重传


当发生了「超时重传」，则就会使用拥塞发生算法。

这个时候，ssthresh 和 cwnd 的值会发生变化：

ssthresh 设为 cwnd/2，

cwnd 重置为 1


![](../pics/a3.png)

接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。

当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。

TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：

cwnd = cwnd/2 ，也就是设置为原来的一半;

ssthresh = cwnd;

进入快速恢复算法


![](../pics/a4.png)

拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；

重传丢失的数据包；

如果再收到重复的 ACK，那么 cwnd 增加 1；

如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated  ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态


也就是没有像「超时重传」一夜回到解放前，而是还在比较高的值，后续呈线性增长。