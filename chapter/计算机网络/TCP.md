# TCP #

Transmission Control protocol 传输控制协议

面向连接的  面向字节流  可靠的传输层协议

![](../pics/n1.png)

源端口号 目的端口号 ： 各占两个字节

序号： 占四个字节。 对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。

确认号：占4个字节。 期望收到下一个报文段的序号。 例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。

首部长度： 一个字节。数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。

确认ACK:当ACK=1时，确认号字段有效。否则无效，TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 

同步SYN:在建立连接时用来同步序号。当SYN=1,ACK=0时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。

终止FIN：用来释放一个连接，当FIN=1时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。

窗口： 占两个字节。窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

检验和：占两个字节。 检验和字段检验的范围包括首部和数据这两个部分。在计算检验和时，在TCP报文段的前面加上12字节的伪首部。

套接字： TCP连接的端点叫做套接字或插口。端口号拼接到IP地址即构成了套接字。



##三次握手、四次挥手

**三次握手： **

建立一个TCP连接时，需要客户端和服务段总共发送三个包。来确认双方的接受、发送能力是否正常、指定自己的初始化序列号并为之后的可靠性传送做准备。

连接服务器指定端口，建立TCP连接，并同步双方的序列号和确认号，交换TCP窗口大小信息。

刚开始客户端处于关闭状态，服务器处于Listen状态。

![](../pics/b1.png)

第一次握手：客户端给服务段发送一个 SYN 报文，并指明客户端的初始化序列号。此时客户端处于SYN_SENT状态。

首部的SYN=1 , 初始序号 seq=x 。 SYN=1的报文不能携带数据，但要消耗一个序号。

第二次握手：服务段在收到客户端的SYN报文之后，会为自己的SYN报文作为应答。并且也指定了自己的初始化序列号。

同时将x+1 作为自己的确认号 ack,表示自己已经收到了客户端的SYN,此时服务器处于SYN_RCVD

在确认报文中: SYN=1 ACK=1 seq=y ack=x+1

第三次握手：客户端在收到SYN报文之后，会发送一个ACK报文，将服务器的序号+1作为自己的确认号，表示已收到服务段SYN，此时服务器处于ESTABLISHED状态，此时，双方建立起了连接。

确认报文 ACK=1 seq=x+1 ack=y+1

在socket编程中，客户端执行connect()时，将触发三次握手。


**四次挥手：**

终止一个连接要经过四次挥手，这是由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。

刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：


![](../pics/b2.png)

第一次挥手： 客户端发送一个FIN报文，报文中指定一个序列号。此时客户端处于 FIN_WAIT1状态。

发出释放连接的报文： FIN=1 seq=u 并停止再发送数据，主动关闭TCP连接进入，FIN_WAIT1状态,等待服务段的确认。

第二次挥手： 服务端收到FIN后，会发送ACK报文，且把客户端序号+1作为ACK确认序列值，表明已收到客户端的报文，此时服务器处于CLOSE_WAIT

即服务段收到客户端连接释放请求即发出确认报文段 ACK=1 序号seq=v 确认号ack=u+1 

此时TCP连接处于 半关闭状态。 客户端到服务段的连接释放。 客户端收到服务段的确认报文后，进行FIN_WAIT2状态，等待服务端发出的连接释放。


第三次挥手： 如果服务段也想释放连接，则需要向客户端 发送FIN报文,此时服务段处于LAST_ACK状态

服务端向客户端发出释放连接报文  FIN=1 ACK=1 序号seq=w 确认号ack=u+1 ，服务段进行LAST_ACK状态，等待客户端最终的确认。

第四次挥手，客户端在收到FIN后，发送ACK报文给服务段

ACK=1 seq=u+1 ack=w+1  客户端进入TIME_WAIT状态 ， 此时TCP未释放掉，2MSL后，客户端才进入CLOSED状态。



**为什么需要三次握手**

需要三次握手才能确认双方的接收与发送能力是否正常。


**为什么需要四次挥手**

因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。

但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。


![](../pics/b3.png)


**重传机制**

可靠传输实现方式之一： 序列号和确认号   seq=100---->   ack=101----->

如果数据在传输过程中丢失了。 TCP针对数据包丢失情况-->重传机制

**超时重传**

当发送报文时，设置一个计时器，当超过指定的时间后，没有收到对方的ack确认应答报文，就会重发该数据。

在以下两种情况会发生超时重传
1. 数据包丢失
2. 确认应答丢失

RTT指从发送报文到接受到确认报文的时间

超时重传时间是以 RTO （Retransmission Timeout 超时重传时间）表示。

![](../pics/b4.png)


超时重传时间 RTO 的值应该略大于报文往返 RTT 的值

因为网络状态是经常变化的，所以RTT也会变化，需要对RTT进行采样，加权平均得出最后的RTO

如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是超时间隔RTO加倍。

如果超时重发的数据，再次超时，又需要重传的时候，都会将下一次超时时间间隔设置为先前值得两倍。两次重复发送就说明网络环境差，不宜频繁发送。

超时重传周期可能相对较长，所以又提出了快速重传的方式。

**快速重传**

快速重传机制不以时间为驱动，而是以数据为驱动

![](../pics/b5.png)

发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。

最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。

快速重传机制只解决了一个问题，就是超时时间的问题，

但是它依然面临着另外一个问题。就是重传的时候，是重传之前的一个，还是重传所有的问题。

---SACK 头部选项中加 SACK 可以确定哪段数据发生丢失

**滑动窗口**

TCP是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。 这样效率太低了。

数据包的往返时间越长，通信的效率就越低。

为解决这个问题，TCP 引入了窗口这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。

有了窗口，就可以指定窗口大小，窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。

窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。

假设窗口大小为 3 个 TCP 段，那么发送方就可以「连续发送」 3 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：

![](../pics/b6.png)

图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫累计确认或者累计应答。

TCP 头里有一个字段叫 Window，也就是窗口大小。

这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。

于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。

通常窗口的大小是由接收方的窗口大小来决定的。

发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。

![](../pics/b7.png)

当发送方把 发送窗口数据全部发送出去后，可用窗口大小就变成0了。 在没有收到ACK确认之前无法继续发送数据了。

在收到5个字节（比如）的ACK应答之后，窗口向右滑5个字节。

TCP通过三个指针来跟踪四个传输类别中每一个类别中的字节。


![](../pics/b8.png)

可用窗口大小=SND.WND-(SND.NXT-SND.UNA)

因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。


**流量控制**

发送端在发送数据时需考虑到接收方的接收处理能力。

如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。

TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。

由于发送窗口和接收窗口并不是不变的，发送窗口和接收窗口存放的字节数，都是存放在操作系统内存缓冲区中的。而操作系统的缓冲区，会被操作系统调整。

TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。

TCP 通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。

如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。

![](../pics/b9.png)

可能产生死锁现象。

为了解决这个问题，TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。

如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。

窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 RST 报文来中断连接。


**拥塞控制**

在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大....

所以TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。

拥塞控制，控制的目的就是避免「发送方」的数据填满整个网络。

为了在「发送方」调节所要发送数据的量，定义了一个叫做「拥塞窗口」的概念。

拥塞窗口 cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。

发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于加入了拥塞窗口的概念后，

此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。

拥塞窗口 cwnd 变化的规则：

只要网络中没有出现拥塞，cwnd 就会增大；
但网络中出现了拥塞，cwnd 就减少；

其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络出现了用拥塞。

拥塞控制主要是四个算法：

慢启动

拥塞避免

拥塞发生

快速恢复



