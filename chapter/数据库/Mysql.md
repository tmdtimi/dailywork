# mysql


![](../pics/1.png)


![](../pics/2.png)



## **一条查询语句的执行过程** ##

系统和Mysql进行交互，驱动会帮我们建立连接。

一次sql查询就会建立一个连接，java 系统在通过 MySQL 驱动和 MySQL 数据库连接的时候是基于 TCP/IP 协议的，所以如果每个请求都是新建连接和销毁连接，那这样势必会造成不必要的浪费和性能的下降。所以采用数据库连接池的方式，如druid、C3P0等。

系统在访问Mysql数据库的时候，建立的连接不是每次请求都去创建的，而是从数据库连接池中获取，这样就解决了反复的创建连接和销毁连接带来的性能损耗问题。

业务系统是并发的，所以Mysql架构体系中也提供了一个池子，作为数据库连接池，双方都是通过数据库连接池来管理连接的。


![](../pics/s1.png)

Mysql可以大体分为Server层和存储引擎层两部分。

Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务 功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在 这一层实现，比如存储过程、触发器、视图等。

而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、 Memory等多个存储引擎。

create table建表的时候，如果不指定引擎类型，默认使用的就是InnoDB，也可以指定引擎。

不同的存储引擎是共用一个Server层的，也就是连接器到执行器的部分。

**连接器**

连接器负责和客户端建立连接，获取权限，维持和管理连接。

mysql -h$ip -P$root -u$user -p$password

在完成TCP连接后，验证账号密码。 用户名密码通过后会到权限表中查出你拥有的权限。

连接完成后，若无后续操作，则此连接处于空闲状态。wait_timeout值默认8小时，客户端8小时没动静会自动断开连接。

长连接：连接成功后，客户端持续有请求，则一直使用同一个连接。短链接是指每次执行完很少的几次查询就断开连接，下次查询重新建立。

连接过程比较复杂，一般采用长连接

但是临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候 才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现 象看就是MySQL异常重启了。

解决此问题可以采取两种方案：

1：定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开 连接，之后要查询再重连。

2：可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。

**查询缓存**

Mysql在执行查询请求时，会先到查询缓存中查看是否之前执行过这条语句。如果是，直接返回，如果不是，就会继续后面的执行过程。

执行完成后，执行结果会被存入查询缓存。

查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。

对于更新压力大的数据库 来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。 比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。

可以将参数query_cache_type设置成 DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语 句，可以用SQL_CACHE显式指定

MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有 这个功能了。

**分析器**

如果没有命中查询缓存，就直接开始执行语句了。

对SQL语句进行解析，首先识别，字符串中的关键字。然后进行句法分析，根据语法规则判断是否有错误。

**优化器**

优化器是在表中有多个索引的时候，选择使用哪一个;或者在一个语句有多表关联的时候，决定各个表的连接顺序。 

优化器阶段结束后，语句的执行方案就确定了，然后进行执行器阶段。

**执行器**

开始执行语句。首先判断你对表有没有执行的权限，如果没有则返回错误。

如果有，则打开表继续执行。打开表的时候，执行器会根据表的引擎定义，引用这个引擎提供的接口。 找到这一行。

你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了 多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。

在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 引 rows_examined r 并不是完全相同的。




## 一条更新语句的执行过程 ##

**redo log  bin log**

如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到 对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。

Mysql提供一种Wal技术，write-ahead logging :先写日志，再写磁盘。

具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log（粉板）里 面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作 记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。

InnoDB的redo log是固定大小的，如可以配置未四个文件，每个1GB

![](../pics/s2.png)


