# mysql


![](../pics/1.png)


![](../pics/2.png)



## **一条查询语句的执行过程** ##

系统和Mysql进行交互，驱动会帮我们建立连接。

一次sql查询就会建立一个连接，java 系统在通过 MySQL 驱动和 MySQL 数据库连接的时候是基于 TCP/IP 协议的，所以如果每个请求都是新建连接和销毁连接，那这样势必会造成不必要的浪费和性能的下降。所以采用数据库连接池的方式，如druid、C3P0等。

系统在访问Mysql数据库的时候，建立的连接不是每次请求都去创建的，而是从数据库连接池中获取，这样就解决了反复的创建连接和销毁连接带来的性能损耗问题。

业务系统是并发的，所以Mysql架构体系中也提供了一个池子，作为数据库连接池，双方都是通过数据库连接池来管理连接的。


![](../pics/s1.png)

Mysql可以大体分为Server层和存储引擎层两部分。

Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务 功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在 这一层实现，比如存储过程、触发器、视图等。

而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、 Memory等多个存储引擎。

create table建表的时候，如果不指定引擎类型，默认使用的就是InnoDB，也可以指定引擎。

不同的存储引擎是共用一个Server层的，也就是连接器到执行器的部分。

**连接器**

连接器负责和客户端建立连接，获取权限，维持和管理连接。

mysql -h$ip -P$root -u$user -p$password

在完成TCP连接后，验证账号密码。 用户名密码通过后会到权限表中查出你拥有的权限。

连接完成后，若无后续操作，则此连接处于空闲状态。wait_timeout值默认8小时，客户端8小时没动静会自动断开连接。

长连接：连接成功后，客户端持续有请求，则一直使用同一个连接。短链接是指每次执行完很少的几次查询就断开连接，下次查询重新建立。

连接过程比较复杂，一般采用长连接

但是临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候 才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现 象看就是MySQL异常重启了。

解决此问题可以采取两种方案：

1：定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开 连接，之后要查询再重连。

2：可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。

**查询缓存**

Mysql在执行查询请求时，会先到查询缓存中查看是否之前执行过这条语句。如果是，直接返回，如果不是，就会继续后面的执行过程。

执行完成后，执行结果会被存入查询缓存。

查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。

对于更新压力大的数据库 来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。 比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。

可以将参数query_cache_type设置成 DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语 句，可以用SQL_CACHE显式指定

MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有 这个功能了。

**分析器**

如果没有命中查询缓存，就直接开始执行语句了。

对SQL语句进行解析，首先识别，字符串中的关键字。然后进行句法分析，根据语法规则判断是否有错误。

**优化器**

优化器是在表中有多个索引的时候，选择使用哪一个;或者在一个语句有多表关联的时候，决定各个表的连接顺序。 

优化器阶段结束后，语句的执行方案就确定了，然后进行执行器阶段。

**执行器**

开始执行语句。首先判断你对表有没有执行的权限，如果没有则返回错误。

如果有，则打开表继续执行。打开表的时候，执行器会根据表的引擎定义，引用这个引擎提供的接口。 找到这一行。

你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了 多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。

在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 引 rows_examined r 并不是完全相同的。




## 一条更新语句的执行过程 ##

**redo log  bin log**

如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到 对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。

Mysql提供一种Wal技术，write-ahead logging :先写日志，再写磁盘。

具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log（粉板）里 面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。

InnoDB的redo log是固定大小的，如可以配置未四个文件，每个1GB

![](../pics/s2.png)

write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。 checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件.

write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos 追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint推进一下。

有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个 能力称为crash-safe.

Mysql大体分为两层，Server层主要负责功能层面的事。引擎层负责存储的相关事宜。redo log是InnoDB特有的日志，而Server层也有自己的日志。

早期Mysql并没有InnoDB引擎。自带的是MyISAM，它并没有crash-safe的能力，binlog日志只能用于归档。

InnoDB是以一个插件的形式引入Mysql的。仅靠binlog无法实现crash-safe，所以InnoDB引入了redo log。

redo log 和 bin log 差异：

1. redolog是InnoDB特有的，binlog是Server层实现的。所有引擎都可以使用
2. redolog是物理日志，记录的“在某个数据页做了什么修改”，bin log是逻辑日志，记录的是这个语句的原始逻辑，“给ID=2这一样的c+1”
3. redolog是循环写的，空间固定会用完。binlog是可以追加写入的。写到一定大小后会切换到下一个，并不会覆盖以前的日志。


![](../pics/s3.png)

update内部流程

1. 执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。 


2. 执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行 数据，再调用引擎接口写入这行新数据。


3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。 


4. 执行器生成这个操作的binlog，并把binlog写入磁盘。 


5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。

**两阶段提交**

两阶段提交-->为了让两份日志之间的逻辑一致。  如何让数据库恢复到半个月内任意一秒的状态？

binlog会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的DBA承 诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期 做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。

当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：

首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库； 然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。

这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去

binlog会记录所有的逻辑操作，可以根据binlog来进行备份恢复。

但是考虑，执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash。此过程如果不两阶段提交，就会出现如下问题：

先写binlog，再写redolog。 binlog写进去了然后崩溃了，但redolog没有完成。此时此事务失效，但按照binlog中的恢复，是已经完成事务的状态，这样就多了一个事务。

如果先写redolog，再写binlog。redolog写进去后崩溃了，Mysql进程异常重启，使用binlog中的恢复，则使已经完成的事务失效。

所以使用两阶段提交 ： redolog prepare -> binlog ->redolog commit

redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候， 表示每次事务的redo log都直接持久化到磁盘。这个参数我建议你设置成1，这样可以保证 MySQL异常重启之后数据不丢失。


sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建 议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失


##事务 ##

事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在Mysql中，事务支持是在引擎层实现的。

并不是所有引擎都支持事务，比如原生的MyISAM就不支持，InnoDB是支持的。

事务四大特性：ACID

Isolation: 隔离级别

当数据库上有多个事务同时执行的时候，可能出现脏读，不可重复读，幻读的问题。为了解决这些问题，就有了隔离级别的概念。

隔离性越强，效率越低，所以要在两者间寻求一个平衡点。

SQL的事务隔离级别包括：读未提交、读提交、可重复读、串行化 四个级别。

读未提交：一个事务未被提交，它做的变更就能被别的事务看到。

读提交：只一个事务提交后，其他事务才能看到它做的变更。

可重复读：一个事务执行过程中看到的数据，总是和事务启动时看到的数据是一致的。

串行化：对同一行记录，读写都会加锁。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

![](../pics/s4.png)

读未提交： v1=2 v2=2 v3=2

读提交： v1=1 v2=2 v3=2

可重复读： v1=1 v2=1 v3=2

串行化： v1=1 v2=1 v3=2 事务B修改值的时候会被锁住，等待事务1提交才能继续。

在实现上，数据库会创建一个视图，访问的时候以事务的逻辑结构为准。

可重复读级别下： 这个视图是在事务启动时创建，整个事务期间都用这个视图。

读提交级别下：这个视图是在每个SQL语句开始执行时创建。

读未提交直接返回记录上的最新值，没有视图概念。

串行化直接采用加锁的方式来避免并行访问。

**事务隔离级别的实现**

在Mysql中，**实际上每条记录在更新的时候都会同时记录一条回滚操作**。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

![](../pics/s5.png)

对于可重复读，每个事务都会创建一个视图。

不同时刻启动的事务会有不同的read-view

在视图A、B、C中，这一个记录的值分别为 1 ，2 ，4 同一条记录在系统中可能存在不同的版本，这就是数据库的多版本并发控制MVCC。

要得到1，就必须依次执行途中的所有回滚得到。
	
回滚日志在不需要的时候会被删除。系统会进行判断需不需要此回滚日志。

当系统中没有比这个回滚日志更早的read-view的时候---不需要

不推荐长事务的理由--意味着系统中存在很老的事务视图。

由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。

除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。

**事务的启动方式**

避免长事务：

1. 显示启动事务,begin或start transaction 配套提交commit 回滚 rollback
2. set autocommit=0 不会自动提交 执行一个select事务启动，并不会自动提交

有些客户端连接框架会默认连接成功后先执行一个set autocommit=0的命令。这就导致接下来的 查询都在事务中，如果是长连接，就导致了意外的长事务。

建议你总是使用set autocommit=1, 通过显式语句的方式来启动事务。

begin显式启动的事务，如果执行commit则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语 句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。 

可以在information_schema库的innodb_trx这个表中查询长事务，比如下面这个语句，用于查 找持续时间超过60s的事务

	select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60




## 索引 ##

索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。

**索引常见模型**

提高读写效率的数据结构 ：哈希表、有序数组和搜索树。

哈希索引做区间查询的速度是很慢的。如果相查给定区间的数据，只能全部扫描一遍。

哈希表这种结构适用于只有等值查询的场景，比如Memcached及其他一些NoSQL引擎。

有序数组在等值查询和范围查询场景中的性能就都非常优秀。

假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你 要查ID_card_n2对应的名字，用二分法就可以快速得到，这个时间复杂度是O(log(N))

这个索引结构支持范围查询。

如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。

有序数组索引只适用于静态存储引擎。

二叉搜索树：

![](../pics/s6.png)

当然为了维持O(log(N))的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是O(log(N))

多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右 递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因 是，索引不止存在内存中，还要写到磁盘上。

为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。这里，“N叉”树中的“N”取决于数据块的大小
                            
一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在 机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。也就是说，对于一个100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间，这个查询可真够慢的

为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。这里，“N叉”树中的“N”取决于数据块的大小


N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中。

MySQL中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。

**InnoDB的索引模型**

在InnoDB中，表是根据主键顺序以索引的形式存放的。InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。

每一个索引在InnoDB里面对应一棵B+树。

	mysql> create table T( id int primary key, k int not null, name varchar(16), index (k))engine=InnoDB;

![](../pics/s7.png)

索引类型分为主键索引和非主键索引。

主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）

非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引 （secondary index）

**基于主键索引和普通索引查询有什么区别**

如果语句是select *fromTwhere ID=500，即主键查询方式，则只需要搜索ID这棵B+树；

如果语句是select *fromTwhere k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID 的值为500，再到ID索引树搜索一次。这个过程称为回表

基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。







                                                
