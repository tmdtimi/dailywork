## java内存模型和线程

对于计算量相同的任务，程序线程并发协调的越有条不紊，效率自然就会更高。反之，线程频繁征用数据，互相阻塞或者死锁，将大大降低程序的并发能力。

CPU计算需要与内存交互，如读取运算数据、存储运算结果等，这个IO操作是很难消除的。由于计算机的存储设备和处理器的运算速度有着几个数量级的差距。所以计算机需要在处理器和内存之间加上一层或多层读写速度尽可能接近处理器运算速度的高速缓存作为内存和处理器的缓冲。

![](../pics/j1.png)

这种方式引入了一个新的问题，缓存一致性。

在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又都共享同一块主内存区域。可能导致各自的缓存数据不一致。

为了解决这个问题，就需要在各个处理器访问缓存时遵循一些协议，在读写时根据协议来进行操作。

除了增加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，可能会对输入代码进行乱序执行，并将结果重组。

java内存模型JMM主要目的是：定义程序中各种变量的访问规则。如实例字段、静态字段等，不包括线程私有的局部变量和方法参数。

![](../pics/j2.png)


主内存和本地内存之间的交互协议，定了了8种原子操作来实现。

lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。

unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。

read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用

load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。

use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。

assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。

store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。

write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。


**Volatile变量的特殊规则**

当一个变量被Volatile修饰： 

1：保证了此变量对所有现成的可见性

可见性指当一个线程修改了这个变量的值，新值对于其他线程是立即可知的。

普通变量的值在线程之间传递是要通过主内存来完成的。

但并不代表，volatile变量的运算在并发下是线程安全的。

java中的运算操作符并非原子操作，仍需要通过加锁来保证变量原子性。

volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，仍要通过加锁来保证原子性。

.：运算结果不依赖变量的当前值，能够保证只有单一线程修改变量的值

.:变量不需要与其他的状态变量共同参与不变约束

2：禁止指令重排序优化

普通变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证赋值操作的顺序和程序代码中执行的顺序一直。

在有volatile修饰的变量，在赋值后多执行了一个lock add相当于一个内存屏障，指重排序不能把后面的指令排到内存屏障之前的地方。

重排序：

编译器优化的重排序 编译器在不改变单线程语义的情况下，会对执行语句进行重新排序。

指令集重排序 现代操作系统中的处理器都是并行的，如果执行语句之间不存在数据依赖性，处理器可以改变语句的执行顺序

内存重排序 由于处理器会使用读/写缓冲区，出于性能的原因，内存会对读/写进行重排序

volatile 禁用的是编译器重排序和处理器重排序。



















**原子性、可见性、有序性**

JMM围绕在并发过程中，如何处理原子性、可见性、有序性建立的。

1：原子性

由java内存模型来直接保证原子性变量操作包括read、load、assign、use、store、write。基本数据类型的访问、读写都是具备原子性的(long、double还需遵守一些协定)

如果应用场景需要一个更大范围的原子性保证，JMM提供了lock和unlock操作。

虚拟机未将lock、unlock开放给用户使用，但是提供了更高层次的字节码指令，monitorenter\monitorexit

2:可见性

可见性指当一个线程修改了共享变量的值，其他线程能够立即得知此修改。

java内存模型是通过，变量在修改后将新值同步回主内存，以及每次使用前立即从主内存刷新变量值这种依赖主内存作为传递媒介的方式实现的。

volatile 变量和 普通变量区别就在于，volatile变量保证了新值能立即同步到主内存，以及每次使用前立即从主内存中刷新。

java中synchronized和final都能实现可见性

同步块的可见性，对一个变量执行unlock操作之前，必须把此变量同步回主内存中。

被final修饰的字段一旦被初始化完成，并且构造器没有把"this"引用传递出去，那么在其他线程中就能看见final字段的值。


3：有序性

java提供volatile和synchronized保证线程之间操作的有序性。

volatile本身就包含了禁止指令重排序的语义

synchronized则是由“一个变量在同一时刻只允许一条线程对其进行lock操作”

**先行发生原则**

Happens-Before 原则






