## JUC

### 线程和进程 ###

程序：是指令和数据的有序集合，静态的概念

进程：是程序的一次执行过程。是程序在执行过程，操作系统分配和管理资源的基本单位，一个进程至少包含一个线程

线程: CPU调度和执行的单位，同一个时刻，，它可与同属一个进程的其他线程共享进程所拥有的全部资源。


每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。



### 线程实现 ###

1：继承Thread类 
	
	public class Demo1 extends Thread {

    int i = 0;
    //重写run方法，run方法的方法体就是现场执行体
    public void run()
    {
        for(;i<100;i++){
            System.out.println(getName()+"  "+i);

        }
    }
    public static void main(String[] args)
    {
        for(int i = 0;i< 100;i++)
        {
            System.out.println(Thread.currentThread().getName()+"  : "+i);
            if(i==20)
            {
                new Demo1().start();
                new Demo1().start();
            }
        }
    }
	}


2：实现Runnable接口

	public class Demo1 implements Runnable {
    private int i;
    public void run()
    {
        for(i = 0;i <100;i++)
        {
            System.out.println(Thread.currentThread().getName()+" "+i);
        }
    }
    public static void main(String[] args)
    {
        for(int i = 0;i < 100;i++)
        {
            System.out.println(Thread.currentThread().getName()+" "+i);
            if(i==20)
            {
                Demo1 rtt = new Demo1();
                new Thread(rtt,"新线程1").start();
                new Thread(rtt,"新线程2").start();
            }
        }

    }
	}




3：实现callable接口

	public class Demo1 implements Callable<Integer> {

    public static void main(String[] args)
    {
        Demo1 ctt = new Demo1();
        FutureTask<Integer> ft = new FutureTask<>(ctt);
        for(int i = 0;i < 100;i++)
        {
            System.out.println(Thread.currentThread().getName()+" 的循环变量i的值"+i);
            if(i==20)
            {
                new Thread(ft,"有返回值的线程").start();
            }
        }
        try
        {
            System.out.println("子线程的返回值："+ft.get());
        } catch (InterruptedException e)
        {
            e.printStackTrace();
        } catch (ExecutionException e)
        {
            e.printStackTrace();
        }

    }

    @Override
    public Integer call() throws Exception
    {
        int i = 0;
        for(;i<100;i++)
        {
            System.out.println(Thread.currentThread().getName()+" "+i);
        }
        return i;
    }
	}




### 线程状态 ###

![Alt pic](https://github.com/tmdtimi/dailywork/blob/main/chapter/%E5%A4%9A%E7%BA%BF%E7%A8%8B/pics/a1.png)


![Alt pic](https://github.com/tmdtimi/dailywork/blob/main/chapter/%E5%A4%9A%E7%BA%BF%E7%A8%8B/pics/a2.png)


sleep()方法作用:让当前线程睡眠一段时间，期间不会释放任何持有的锁。

yield()方法作用：让出该线程的时间片给其它线程。

线程调用了yield()方法，表示放弃当前获得的CPU时间片，回到就绪状态。最后由线程调度重新选择就绪状态的线程分配CPU资源。

join()方法作用：暂停当前线程，等待被调用线程指向结束之后再继续执行。

wait()方法的作用：让该线程处于等待状态。.

wait()方法会释放CPU执行权 和 占有的锁。

线程调用wait()方法后，让该线程处于等待状态。

进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒。

wait和notify必须配套使用，即必须使用同一把锁调用。

notify()方法的作用：唤醒处于wait的线程。..

notifyAll()方法的作用：唤醒所有处于wait状态的线程。



**CAS**

compare and swap

每个线程 i+1： 加锁 加synchronized

cas不用加锁

1拿出来 ， +1=2 ， 把2写回去   写回去得过程中 ， 比较1 和原有地址的值是否相同

如果在写回去的过程中，其他线程有对其修改2，则再次将 2拿出来，+1，写回去。。。重复

![](../pics/11.png)

ABA问题

其他线程，多次修改，又把值修改回1

加个版本号


AtomicInteger: 对int类型的数进行原子性访问

如多个线程操作m++  ---一般情况需要加锁 ----利用	m.incrementAndGet() +1 ----内部使用了CAS锁

lock cmpxchg   如是多cpu就加lock

汇编级别的指令中 加了 lock --有任意指令在使用cpu的时候不能被其他cpu打断--防止在读取比较、写入+1的时候被其他线程打断



**Sychronized**


一般同步方法 锁是当前对象

静态同步方法 锁是当前class对象

同步代码块 锁是括号里的对象



用户态和内核态 ： 操作系统级别的某些指令不准用户级别的程序去访问   OS-JVM 

锁这个资源，需要通过OS去申请到的

JDK早期，Synchronized是重量级锁。因为申请所必须通过linux kernel系统调用。

	Object o =new Object();

对象头： 8个字节markword  4个字节的 classpointer  4个字节的对齐填充

	synchronized(o)


锁信息被记录在了markword里面，使用synchronized(o) ， 实际上是对o的8字节markword进行修改。


markword当中包含的信息：

![](https://github.com/tmdtimi/dailywork/blob/main/chapter/%E5%A4%9A%E7%BA%BF%E7%A8%8B/pics/22.png)


new Object--->普通对象---->synchonized(o)---->轻量级锁/自旋锁（轻度竞争）

![](https://github.com/tmdtimi/dailywork/blob/main/chapter/%E5%A4%9A%E7%BA%BF%E7%A8%8B/pics/33.png)


看markword第一个字节最后两位，标识有无锁、锁类型

后面三个字节为线程指针


![](https://github.com/tmdtimi/dailywork/blob/main/chapter/%E5%A4%9A%E7%BA%BF%E7%A8%8B/pics/44.png)


偏向锁/轻量级锁 ---用户态锁    重量级锁--向内核申请

StringBuffer :方法加 synchronized

大部分使用的时候，只有一个线程。没有必要向操作系统申请使用重量级锁---为什么需要轻量级锁


偏向锁：只是把当前线程指针扔到markword中  

当多线程竞争，先把偏向锁撤销-----自旋锁竞争

每个线程维护一个lock record , 去申请指针指向自己的。

当有其他线程占有时。先等待自旋，不断的去申请。

竞争激烈了---重量级锁 向OS申请


synchronized(){} 翻译成字节码中实际上是： monitorenter  monitorexit

synchronized是可重入锁 ：  偏向锁/自旋锁 --->线程栈--->lock record +1


自旋锁什么时候升级为重量级锁： 自适应自旋 ---配置 、

为什么需要重量级锁：  自旋是占有CPU资源的，如果锁的时间长，或自旋线程多，cpu会大量消耗。

重量级锁:将拿不到锁的线程扔到一个等待队列中 waitset  通过OS kernel 来进行调度


偏向锁是否效率比自旋锁高： 不一定，在明确知道有多线程竞争的时候，偏向锁肯定会撤销，升级为自旋锁。此时应直接使用自旋锁

JVM启动时，有很多默认启动的线程，有很多涉及到sync的代码，所以一定会产生竞争。如果使用偏向锁，就会不断的撤销和升级到自旋锁

所以初始时，偏向锁是不启动的。

当开启偏向锁，初始化对象--称为匿名偏向。 markword指针未指向任何一个线程   



Lock:







