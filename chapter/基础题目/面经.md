**JDK JRE JVM 的区别？**

JVM 就是我们常说的 java 虚拟机，它是整个 java 实现跨平台的 最核心的部分，所有的 java程序会首先被编译为.class 的类文件，这种类文件可 以在虚拟机上执行，也就是说 class 并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解
释给本地系统执行。

JDK = JRE+Java 开发工具

JRE = JVM+核心类库（libs）

JVM 是用来执行字节码文件的



**浏览器输入一个网址会发生什么变化？**

首先浏览器会对此网址进行解析，得到一些 http协议、服务器域名、请求文件路径等信息

然后会根据这些信息，生成HTTP请求。

浏览器需要委托操作系统去向服务段发送其请求，在这之前需要得到服务器的IP地址

DNS解析、通过本地DNS服务器、根DNS服务器、顶级DNS服务器、权威DNS服务器，将域名解析为IP地址。

然后通过操作系统协议栈，TCP、ICMP、ARP等，对请求进行包装传输。

拿到IP地址后，浏览器委托操作系统和服务器建立TCP连接。

连接建立起来之后，浏览器可以向服务器发送HTTP请求。

服务器收到此请求，根据路径参数，经过后台一些处理，把处理的结果返回给浏览器，如完整的html页面代码。

浏览器拿到完整的HTML代码，内核和js引擎就会解析和渲染这个页面，里面的JS，CSS，图片等静态资源也通过一个个HTTP请求进行加载。

浏览器根据拿到的资源对页面进行渲染，最终把完整的页面返回给浏览器。

如果浏览器没有后续的请求，则会和服务器断开TCP连接。


**详细说一下DNS 域名解析服务器？DNS 用的是什么协议（UDP）**

![](../pics/a1.png)


**http中的请求Request、Responce包含什么**

![](../pics/c3.png)

请求行、请求头、请求体

![](../pics/c1.png)

请求行：请求方法、资源路径、协议版本

请求头：

为服务器处理请求提供了额外的信息 如使用的语言和字符集 如果没有请求头，服务器在大多数情况下也能够很好地处理请求

host user-agent cokkie等。。。

请求体：请求体不是必须存在的，它包含了客户端发送给服务器的数据


![](../pics/c2.png)

状态行 响应头 响应体

状态行 ： 协议版本 状态码 状态描述

响应头： 多个属性

响应体： JSON数据


**cookie，session区别联系**

Session 服务端生成的,存放在服务端，默认保存30分钟，也可以放在数据库里。访问太多，为了减轻服务器压力，一般采用第一种方式。

浏览器第一次发请求，会生成session和sessionid对其进行标识，并通过响应发送到浏览器。当浏览器第二次发送请求的时候，会携带此sessionid，在服务器端迅速找到对应session。

session客户端可以通过三种方式保存：1：cookie 如果不设置过期时间，浏览器关闭即消失了。

2:URL附加 3：页面表单添加隐藏域

 
Cookie存放在客户端，属于session的一种，但不占用服务器资源。 但存放在本机，安全性一般。单个Cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个Cookie。

用Cookie 实现Session跟踪的。第一次创建Session时，服务端会通过在HTTP协议中反馈到客户端，需要在 Cookie 中记录一个Session ID，以便今后每次请求时都可分辨你是谁。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？建议使用URL重写技术进行会话跟踪，即每次HTTP交互，URL后面都被附加上诸如 sid=xxxxx 的参数，以便服务端依此识别用户。


cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。

cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。

session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。

服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。

Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。

Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。




**Token**

基于服务器的验证方式暴露出来一系列的问题

1. Session:每次客户端发起请求，服务器会创建一个记录来存储信息，当越来越多的用户发请求，内存开销在不断增大。
2. 可扩展性：在服务器的内存中使用session作登录信息，
3. 跨域资源共享
4. 跨站请求伪造

HTTP请求都是以无状态的形式对接。即HTTP服务器不知道本次请求和上一次请求是否有关联。所以就有了Session的引入，即服务端和客户端都保存一段文本，客户端每次发起请求都带着，这样服务器就知道客户端是否发起过请求。

这样，就导致客户端频繁向服务端发出请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否。而Session的存储是需要空间的，频繁的查询数据库给服务器造成很大的压力。

Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌。当客户端第一次访问服务端，服务端会根据传过来的唯一标识userId，运用一些算法，并加上密钥，生成一个Token，然后通过BASE64编码一下之后将这个Token返回给客户端，客户端将Token保存起来（可以通过数据库或文件形式保存本地）。下次请求时，客户端只需要带上Token，服务器收到请求后，会用相同的算法和密钥去验证Token。

最简单的Token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由Token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接Token请求服务器)。

使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。

客户端使用用户名跟密码请求登录服务端收到请求，去验证用户名与密码验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者数据库里客户端每次向服务端请求资源的时候需要带着服务端签发的 Token服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据

APP登录的时候发送加密的用户名和密码到服务器，服务器验证用户名和密码，如果成功，以某种方式比如随机生成32位的字符串作为Token，存储到服务器中，并返回Token到APP，以后APP请求时，凡是需要验证的地方都要带上该Token，然后服务器端验证Token，成功返回所需要的结果，失败返回错误信息，让他重新登录。

对于同一个APP同一个手机当前只有一个Token；手机APP会存储一个当前有效的Token。其中服务器上Token设置一个有效期，每次APP请求的时候都验证Token和有效期。

每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库token 完全由应用管理，所以它可以避开同源策略

           



**https如何保证安全、证数为什么能够保证安全**

采用非对称加密+对称加密。 不能确保，浏览器得到的公匙来自于服务器，可能是中间人攻击。

需要CA机构确保服务器不是中间人。

CA机构，将数据利用私匙、hash做一个数字签名，作为服务端的证书，并附带公匙。将其传给客户端，并给客户端提供公匙进行验证。

客户端生成一个用于对称加密的随机Key，并用证书内的公钥Pub进行加密，发送给服务端；

服务端收到随机Key的密文，使用与公钥Pub配对的私钥Private进行解密，得到客户端真正想发送的随机Key；

服务端使用客户端发送过来的随机Key对要传输的HTTP数据进行对称加密，将密文返回客户端；

客户端使用随机Key对称解密密文，得到HTTP数据明文；

后续HTTPS请求使用之前交换好的随机Key进行对称加解密。



**值传递、引用传递**

栈、堆

栈由编译器自动分配释放，用于存放函数的参数值，局部变量等。

就java来说，基本类型值将直接存在栈上，而引用类型的值是存在堆上，栈上存储对该对象的引用地址。

对于基本类型的值来说，赋值运算符会直接改变变量的值。

对于引用类型，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉，但是原来的对象不会被改变。


**HashMap和HashTable**

HashMap线程不安全，多线程处理容易产生死循环。但是在单线程下运行效率高。

HashTable线程安全，很多方法都用synchronized修饰，但是因为加锁单线程下效率较低。

HashMap允许有一个key为null，允许多个value为null。HashTable不允许key或value为null。

Hashtable 继承了 Dictionary类，而 HashMap 继承的是 AbstractMap 类。

HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75。

当现有容量大于总容量 * 负载因子时，HashMap 扩容规则为当前容量翻倍，Hashtable 扩容规则为当前容量翻倍 + 1。

HashMap 中的 Iterator 迭代器是 fail-fast 的，而 Hashtable 的 Enumerator 不是 fail-fast 的。

所以，当其他线程改变了HashMap 的结构，如：增加、删除元素，将会抛出 ConcurrentModificationException 异常，而 Hashtable 则不会。


**HashMap中链表和红黑树**

hash碰撞后会在entry后面形成一个链表，当元素数超过8的时候，会转换为红黑树。

同样，后续如果由于删除或者其他原因调整了大小，当红黑树的节点小于或等于 6 个以后，又会恢复为链表形态。

链表时间复杂度：O(n) 红黑树时间复杂度：O(logN)

链表空间占用少，转换为红黑树概率是比较小的。

**ConcurrentHashMap**

segment本身相当于HashMap对象，segment包含一个HashEntry数组，每一个entry即是键值对，也是链表的头节点。

并不一定需要像Hashtable一样，当一个线程占有锁的时候其他的线程都必须进入阻塞状态，因此在多线程环境下它更加的高效。

是利用了自旋 + CAS、Synchronized等来保证线程安全。



**CMS G1**

收集器，分代回收。

多数对象朝生夕灭，熬过多次垃圾收集对象更难消亡。

一般新生代收集器收集频率较高，应选用性能较高的收集器。 老年代收集次数比较少，应避免复制算法。

CMS收集器是一种以获取最短回收停顿时间为目标的收集器。

CMS仅用于老年代的收集。基于标记清除算法。

初始标记、并发标记、重新标记、并发清除

初始标记仅仅是标记一下GCroot直接能关联的对象，速度较快。

并发标记就是进行GCrootTracing的过程

重新标记则是为了修正并发标记期间因用户线程运作导致标记产生变动的一部分对象的标记记录。

CMS优点：并发收集，低停顿

CMS收集器之所以能够做到并发，根本原因在于采用基于“标记-清除”的算法并对算法过程进行了细粒度的分解。

标记清除会出现大量的内存碎片，所以不能应用于新生代。

G1重新定义了堆空间，打破了原有的分代模型，而是将堆划分为一个个的区域。

这么做的目的是在进行收集时不必在全堆范围内进行，这是它最显著的特点。

区域划分的好处就是带来了停顿时间可预测的收集模型：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。

G1收集器将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。

初始标记：仅仅标记GCroot能够直接关联到的对象，

并发标记：从GCRoot开始对堆中对象进行可达性分析，找出存活的对象。与用户线程并发执行。

最终标记：修正在并发标记期间因用户线程运作导致标记产生变换的一部分记录。

筛选回收：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，此阶段可与用户线程并发执行。但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。




**接口和抽象类**

抽象类是从子类中发现公共部分，泛化成抽象类，子类继承父类即可。 体现的是一种继承关系。子类和父类 is a 的关系。

设计接口是自上而下的过程,接口规范某一行为,我某类需要这个行为,调用者实现某接口。 接口表示has a的关系。

抽象类只能被单继承，而接口可以多实现。

抽象类是一个类，可以被任意权限修饰符修饰。静态和非静态属性，final和非final属性，可以有抽象方法和非抽象方法。

而接口只能被public final 修饰。接口不能包含成员变量，除了 static 和 final 变量。

接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract

接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。


**ArrayList和LinkedList**

ArrayList是动态数组，初始容量为10，每次插入会检查是否需要扩容。ArrayList支持随机访问

而LinkedList是双向链表。LinkedList还支持remove\get\insert方法在LinkedList的首部或尾部。


**volatile关键字**

cpu和主内存交互，如读取运算数据、存储运算结果等，这个IO操作是很难消除的。

所以在每个cpu和内存之间，都加上了和cpu运算速度和内存读写速度差不多的高速缓存作为cpu和主内存的缓冲区。

在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又都共享同一块主内存区域。可能导致各自的缓存数据不一致。

所以各个处理器访问缓存时遵循一些协议，在读写时根据协议来进行操作。

主内存和缓存之间的交互协议就提供了8个原子指令来进行。lock/unlock/read/write/load/assign/use/store等

JMM这个模型是围绕原子性、可见性、有序性建立的。

可见性：

synchronized:某一个线程进入synchronized代码块前后，线程会获得锁，清空工作内存，从主内存拷贝共享变量最新的值到工作内存成为副本，执行代码，将修改后的副本的值刷新回主内存中，线程释放锁。

而获取不到锁的线程会阻塞等待，所以变量的值肯定一直都是最新的。

每个线程操作数据的时候，需要先从主内存读取到自己的工作内存，当某个线程对数据进行了操作，其他线程读取变量副本就失效了。需要再次在主内存中读取。

volatile保证不同线程对共享变量操作的可见性。当一个线程修改了volatile变量写回主内存时，另一个线程立即看到最新的值。

缓存一致性协议：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。

每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。

由于Volatile的MESI缓存一致性协议，需要不断的从主内存嗅探和cas不断循环，无效交互会导致总线带宽达到峰值。

为了提高性能，编译器和处理器常常会对既定的代码执行顺序进行指令重排序。

java编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。

上面的我提过重排序原则，为了提高处理速度，JVM会对代码进行编译优化，也就是指令重排序优化，并发编程下指令重排序会带来一些安全隐患：如指令重排序导致的多个线程操作之间的不可见性。

volatile在读写时插入内存屏障，然后禁止指令重排。


**Lock锁和synchronized锁区别**

Lock是一个接口 synchronized是关键字

1.synchronized是JVM层面的锁，而Lock是API层面的锁。

2.手动释放

synchronized不需要用户去手动释放锁，，synchronized 代码执行完后系统会自动让线程释放对锁的占用。

ReentrantLock则需要用户去手动释放锁，如果没有手动释放锁，就可能导致死锁现象。一般通过lock()和unlock()方法配合try/finally语句块来完成，使用释放更加灵活。

3.是否可中断

synchronized是不可中断类型的锁，除非加锁的代码中出现异常或正常执行完成

ReetrantLock可以中断。可以通过trylock(long timeout,TimeUnit unit)设置超时方法或者将lockInterruptibly()放到代码块中，调用interrupt方法进行中断。

4：是否公平锁

synchronized为非公平锁

ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法new ReentrantLock时传入boolean值进行选择，为空默认false非公平锁，true为公平锁。

5：锁是否可绑定条件Condition

synchronized不能绑定

eentrantLock通过绑定Condition结合await()/singal()方法实现线程的精确唤醒，而不是像synchronized通过Object类的wait()/notify()/notifyAll()方法要么随机唤醒一个线程要么唤醒全部线程。

6：锁的对象

synchronzied锁的是对象，锁是保存在对象头里面的，根据对象头数据来标识是否有线程获得锁/争抢锁

ReentrantLock锁的是线程，根据进入的线程和int类型的state标识锁的获得/争抢。

**线程池的工作模式**

ThreadPoolExcutor 创建 / Executors创建

excutor() submit()执行这个线程

核心线程池 / 任务阻塞队列 / 创建非核心线程 / 拒绝策略

AbortPolicy：抛出异常RejectedExecutionException的RuntimeException

DiscardPolicy: 当新任务被提交后直接被丢弃掉，也不会给你任何的通知

DiscardOldestPolicy: 如果线程池没被关闭且没有能力执行，则会丢弃任务队列中的头结点，通常是存活时间最长的任务，这种策略与第二种不同之处在于它丢弃的不是最新提交的，而是队列中存活时间最长的，这样就可以腾出空间给新提交的任务，但同理它也存在一定的数据丢失风险。

CallerRunsPolicy:当有新任务提交后，如果线程池没被关闭且没有能力执行，则把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务。

新提交的任务不会被丢弃，这样也就不会造成业务损失. 提交任务的线程就得负责执行任务，在这段期间，提交任务的线程被占用，也就不会再提交新的任务，


** ThreadLocal原理**

