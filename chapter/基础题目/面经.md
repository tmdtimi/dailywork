**JDK JRE JVM 的区别？**

JVM 就是我们常说的 java 虚拟机，它是整个 java 实现跨平台的 最核心的部分，所有的 java程序会首先被编译为.class 的类文件，这种类文件可 以在虚拟机上执行，也就是说 class 并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解
释给本地系统执行。

JDK = JRE+Java 开发工具

JRE = JVM+核心类库（libs）

JVM 是用来执行字节码文件的



**浏览器输入一个网址会发生什么变化？**

首先浏览器会对此网址进行解析，得到一些 http协议、服务器域名、请求文件路径等信息

然后会根据这些信息，生成HTTP请求。

浏览器需要委托操作系统去向服务段发送其请求，在这之前需要得到服务器的IP地址

DNS解析、通过本地DNS服务器、根DNS服务器、顶级DNS服务器、权威DNS服务器，将域名解析为IP地址。

然后通过操作系统协议栈，TCP、ICMP、ARP等，对请求进行包装传输。

拿到IP地址后，浏览器委托操作系统和服务器建立TCP连接。

连接建立起来之后，浏览器可以向服务器发送HTTP请求。

服务器收到此请求，根据路径参数，经过后台一些处理，把处理的结果返回给浏览器，如完整的html页面代码。

浏览器拿到完整的HTML代码，内核和js引擎就会解析和渲染这个页面，里面的JS，CSS，图片等静态资源也通过一个个HTTP请求进行加载。

浏览器根据拿到的资源对页面进行渲染，最终把完整的页面返回给浏览器。

如果浏览器没有后续的请求，则会和服务器断开TCP连接。


**详细说一下DNS 域名解析服务器？DNS 用的是什么协议（UDP）**

![](../pics/a1.png)


**http中的请求Request、Responce包含什么**

![](../pics/c3.png)

请求行、请求头、请求体

![](../pics/c1.png)

请求行：请求方法、资源路径、协议版本

请求头：

为服务器处理请求提供了额外的信息 如使用的语言和字符集 如果没有请求头，服务器在大多数情况下也能够很好地处理请求

host user-agent cokkie等。。。

请求体：请求体不是必须存在的，它包含了客户端发送给服务器的数据


![](../pics/c2.png)

状态行 响应头 响应体

状态行 ： 协议版本 状态码 状态描述

响应头： 多个属性

响应体： JSON数据


**cookie，session区别联系**

Session 服务端生成的,存放在服务端，默认保存30分钟，也可以放在数据库里。访问太多，为了减轻服务器压力，一般采用第一种方式。

浏览器第一次发请求，会生成session和sessionid对其进行标识，并通过响应发送到浏览器。当浏览器第二次发送请求的时候，会携带此sessionid，在服务器端迅速找到对应session。

session客户端可以通过三种方式保存：1：cookie 如果不设置过期时间，浏览器关闭即消失了。

2:URL附加 3：页面表单添加隐藏域

 
Cookie存放在客户端，属于session的一种，但不占用服务器资源。 但存放在本机，安全性一般。单个Cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个Cookie。

用Cookie 实现Session跟踪的。第一次创建Session时，服务端会通过在HTTP协议中反馈到客户端，需要在 Cookie 中记录一个Session ID，以便今后每次请求时都可分辨你是谁。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？建议使用URL重写技术进行会话跟踪，即每次HTTP交互，URL后面都被附加上诸如 sid=xxxxx 的参数，以便服务端依此识别用户。


cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。

cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。

session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。

服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。

Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。

Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。




**Token**

基于服务器的验证方式暴露出来一系列的问题

1. Session:每次客户端发起请求，服务器会创建一个记录来存储信息，当越来越多的用户发请求，内存开销在不断增大。
2. 可扩展性：在服务器的内存中使用session作登录信息，
3. 跨域资源共享
4. 跨站请求伪造

HTTP请求都是以无状态的形式对接。即HTTP服务器不知道本次请求和上一次请求是否有关联。所以就有了Session的引入，即服务端和客户端都保存一段文本，客户端每次发起请求都带着，这样服务器就知道客户端是否发起过请求。

这样，就导致客户端频繁向服务端发出请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否。而Session的存储是需要空间的，频繁的查询数据库给服务器造成很大的压力。

Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌。当客户端第一次访问服务端，服务端会根据传过来的唯一标识userId，运用一些算法，并加上密钥，生成一个Token，然后通过BASE64编码一下之后将这个Token返回给客户端，客户端将Token保存起来（可以通过数据库或文件形式保存本地）。下次请求时，客户端只需要带上Token，服务器收到请求后，会用相同的算法和密钥去验证Token。

最简单的Token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由Token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接Token请求服务器)。

使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。

客户端使用用户名跟密码请求登录服务端收到请求，去验证用户名与密码验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者数据库里客户端每次向服务端请求资源的时候需要带着服务端签发的 Token服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据

APP登录的时候发送加密的用户名和密码到服务器，服务器验证用户名和密码，如果成功，以某种方式比如随机生成32位的字符串作为Token，存储到服务器中，并返回Token到APP，以后APP请求时，凡是需要验证的地方都要带上该Token，然后服务器端验证Token，成功返回所需要的结果，失败返回错误信息，让他重新登录。

对于同一个APP同一个手机当前只有一个Token；手机APP会存储一个当前有效的Token。其中服务器上Token设置一个有效期，每次APP请求的时候都验证Token和有效期。

每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库token 完全由应用管理，所以它可以避开同源策略

           



**https如何保证安全、证数为什么能够保证安全**

采用非对称加密+对称加密。 不能确保，浏览器得到的公匙来自于服务器，可能是中间人攻击。

需要CA机构确保服务器不是中间人。

CA机构，将数据利用私匙、hash做一个数字签名，作为服务端的证书，并附带公匙。将其传给客户端，并给客户端提供公匙进行验证。

客户端生成一个用于对称加密的随机Key，并用证书内的公钥Pub进行加密，发送给服务端；

服务端收到随机Key的密文，使用与公钥Pub配对的私钥Private进行解密，得到客户端真正想发送的随机Key；

服务端使用客户端发送过来的随机Key对要传输的HTTP数据进行对称加密，将密文返回客户端；

客户端使用随机Key对称解密密文，得到HTTP数据明文；

后续HTTPS请求使用之前交换好的随机Key进行对称加解密。



**值传递、引用传递**

栈、堆

栈由编译器自动分配释放，用于存放函数的参数值，局部变量等。

就java来说，基本类型值将直接存在栈上，而引用类型的值是存在堆上，栈上存储对该对象的引用地址。

对于基本类型的值来说，赋值运算符会直接改变变量的值。

对于引用类型，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉，但是原来的对象不会被改变。


**HashMap和HashTable**

HashMap线程不安全，多线程处理容易产生死循环。但是在单线程下运行效率高。

HashTable线程安全，很多方法都用synchronized修饰，但是因为加锁单线程下效率较低。

HashMap允许有一个key为null，允许多个value为null。HashTable不允许key或value为null。

Hashtable 继承了 Dictionary类，而 HashMap 继承的是 AbstractMap 类。

HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75。

当现有容量大于总容量 * 负载因子时，HashMap 扩容规则为当前容量翻倍，Hashtable 扩容规则为当前容量翻倍 + 1。

HashMap 中的 Iterator 迭代器是 fail-fast 的，而 Hashtable 的 Enumerator 不是 fail-fast 的。

所以，当其他线程改变了HashMap 的结构，如：增加、删除元素，将会抛出 ConcurrentModificationException 异常，而 Hashtable 则不会。


**HashMap中链表和红黑树**

hash碰撞后会在entry后面形成一个链表，当元素数超过8的时候，会转换为红黑树。

同样，后续如果由于删除或者其他原因调整了大小，当红黑树的节点小于或等于 6 个以后，又会恢复为链表形态。

链表时间复杂度：O(n) 红黑树时间复杂度：O(logN)

链表空间占用少，转换为红黑树概率是比较小的。

**ConcurrentHashMap**

segment本身相当于HashMap对象，segment包含一个HashEntry数组，每一个entry即是键值对，也是链表的头节点。

并不一定需要像Hashtable一样，当一个线程占有锁的时候其他的线程都必须进入阻塞状态，因此在多线程环境下它更加的高效。

是利用了自旋 + CAS、Synchronized等来保证线程安全。



**CMS G1**

收集器，分代回收。

多数对象朝生夕灭，熬过多次垃圾收集对象更难消亡。

一般新生代收集器收集频率较高，应选用性能较高的收集器。 老年代收集次数比较少，应避免复制算法。

CMS收集器是一种以获取最短回收停顿时间为目标的收集器。

CMS仅用于老年代的收集。基于标记清除算法。

初始标记、并发标记、重新标记、并发清除

初始标记仅仅是标记一下GCroot直接能关联的对象，速度较快。

并发标记就是进行GCrootTracing的过程

重新标记则是为了修正并发标记期间因用户线程运作导致标记产生变动的一部分对象的标记记录。

CMS优点：并发收集，低停顿

CMS收集器之所以能够做到并发，根本原因在于采用基于“标记-清除”的算法并对算法过程进行了细粒度的分解。

标记清除会出现大量的内存碎片，所以不能应用于新生代。

G1重新定义了堆空间，打破了原有的分代模型，而是将堆划分为一个个的区域。

这么做的目的是在进行收集时不必在全堆范围内进行，这是它最显著的特点。

区域划分的好处就是带来了停顿时间可预测的收集模型：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。

G1收集器将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。

初始标记：仅仅标记GCroot能够直接关联到的对象，

并发标记：从GCRoot开始对堆中对象进行可达性分析，找出存活的对象。与用户线程并发执行。

最终标记：修正在并发标记期间因用户线程运作导致标记产生变换的一部分记录。

筛选回收：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，此阶段可与用户线程并发执行。但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。




