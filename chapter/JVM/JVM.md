# JVM

## java内存区域与内存溢出

### 运行时数据区域

- 程序计数器

  当前线程所执行字节码的行号治时期。
  
  字节码解释器就是通过改变这个计数器的值来选取吓一跳执行的字节码指令。
  
  线程私有
  
  线程执行java方法，则计数器记录正在执行的虚拟机字节码指令地址。
  
  线程执行native方法，计数器值应为空。
  
  没有OutOfMemoryError
  
  
  

- java虚拟机栈

  线程私有，生命周期与线程相同。
  
  虚拟机栈描述的时java方法执行的线程内存模型：每个方法被执行，虚拟机同步创建一个栈帧，
  用于存储
  
  局部变量表、操作数栈、动态链接、方法出口信息等。
  
  每一个方法被调用直至执行完毕过程，对应一个栈帧从虚拟机栈中从入栈到出栈的过程。
  
  局部变量表存放了编译器已知的各种 基本数据类型、对象引用等。
  
  线程请求的栈深度打羽虚拟机允许的深度：StackOverFlowError
  
  栈扩展时无法申请到足够的内存OutOfMemoryError
  
  
  

- 本地方法栈

  局部变量表 、 方法出口信息 操作数栈
  
  作用与虚拟机栈差不多
  
  但是是在调用本地方法时采用
  

- java堆

  线程共享区域 在虚拟机启动时创建
  
  此内存区域 存放对象实例   由垃圾回收器来管理内存
  
  可以固定大小，也可以时扩展的
  
  -Xmx -Xms
  
  若没有足够内存完成实例分配，并且堆无法扩展时
  
  OutOfMemoryError
  
  
  
  
  

- 方法区

  线程共享的区域
  
  用于存放 虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
  
  方法区为堆的一个逻辑部分。
  
  OutOfMemoryError
  
  运行时常量池是方法区的一部分。
  
  Class文件中，有类的版本、字段、方法、接口等描述信息外。还有常量池表，用于存放编译期产生的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
  
  
  

### 虚拟机对象创建

创建对象: new clone 反序列化

虚拟机收到一条字节码new指令后

首先检查此指令的参数能否在常量池中定位到一个类的符号引用
如果没有，则执行类加载过程。

类加载检查通过后，为新生对象分配内存。

对象所需内存大小在类加载完成后便可完全确定，为对象分配内存任务等同把一块确定大小的内存块从堆中划分出来。

假设java堆中内存是规整的，所有被使用过的内存都被放在一边，空闲的内存被放在一边，中间放着一个指针作为分界点的指示器。分配内存仅仅是把指针向空闲空间方向挪动一段与对象大小相等的距离。---指针碰撞

如果堆中内存不是规整的，虚拟机就必须维护一个列表，记录哪些内存块是可用的。在分配的时候从列表中找到一个足够大的。---空闲列表

Serial \ ParNew 标记整理 ----指针碰撞
CMS  标记清除---空闲列表




### OutOfMemoryError

## 垃圾收集器与内存分配

### 对象已死？

- 引用计数算法
- 可达性分析算法
- 引用

	- 强引用

		- 不会回收

	- 软引用

		- 非必须，内存泄漏时第二次回收

	- 弱引用

		- 生存到下一次垃圾收集

	- 虚引用

		- 收集时系统通知

- 回收方法区

### 垃圾收集算法

- 分代收集理论

	- 多数对象朝生夕灭，熬过多次垃圾收集对象更难消亡

		- Minor GC

			- 新生代垃圾收集

		- MajorGC

			- 老年代垃圾收集

		- MixedGC

			- G1收集器，new和old都收集

		- fullGC

			- 收集整个堆

- 标记-清除

	- 效率不稳定
	- 内存空间碎片化

- 标记-复制

	- 可用内存缩小到原来的一半

- 标记-整理

	- 需暂停用户线程  

### 经典垃圾收集器

- Serial

  单线程工作 -stop the world
  
  新生代 复制算法/暂停所有用户线程
  
  老年代 标记-整理 / 暂停所有用户线程
  
  

- ParNew

  多线程并行收集  
  
  并行 -- 同一时间多条垃圾收集线程协同工作、
  
  新生代 多条线程 复制算法/暂停所有用户线程
  
  老年代 标记-整理 / 暂停所有用户线程
  
  能和CMS老年代收集器配合使用
  
  CMS只能与 serial 和 ParNew配合
  
  ParNew并入CMS 
  
  单核心 Serial要胜于 ParNew
  
  -XX：ParallelGCThread 限制垃圾收集线程数
  

- Parallel Scavenge

  Parallel Scavenge收集器 新生代收集器  标记收集算法 
   多线程并发收集
  
  CMS等收集器目标：缩短垃圾收集用户线程的停顿时间
  
  Parralel Scanvenge: 达到一个可控制的吞吐量
  
  吞吐量：用于运行用户代码的时间与处理器总消耗时间比值。
  
  缩短垃圾收集花费时间比例
  
  控制最大垃圾收集停顿时间:-XX:MaxGCPauseMillis
  
  吞吐量大小 ： -XX:GCTimeRatio
  
  

- Serial Old

  Serial 收集器老年版  单线程收集器
  
  和Parallel Scavenge 配合
  
  作为CMS失败后预案
  
  复制+标记整理
  

- Parallel Old

  Parallel Scavenge Old老年代版本   多线程并发收集
  
  标记-整理
  
  和 Parallel Scavenge 搭配使用
  
  适合吞吐量或处理器资源稀缺的场合
  

- CMS

  Concurrent Mark Sweep : 以获取最短回收停顿时间为目标的收集器。
  
  关注服务响应速度
  
  CMS基于标记-清除
  
  1：初始标记  2：并发标记  3：重新标记 4：并发清除
  
  初始标记 和 重新标记 需要stop the world
  
  初始标记：仅标记GC Root能直接关联的对象
  
  并发标记：从GC Root的直接关联对象开始遍历整个对象图，此过程耗时较长但不需要停顿用户线程。
  
  重新标记：修正并发标记期间，因为用户线程继续运作而导致标记产生的对象标记记录，停顿时间比初始标记长，但远小于并发标记。
  
  并发清除：删除标记阶段判断已经死亡的对象。由于不需要移动存活对象，此阶段可以与用户线程并发进行。
  
  缺点：
  1：占用一部分线程，降低总吞吐量。 CMS默认启动回收线程数为4. 当处理器核心多，则影响会小。当处理器核心不足四个。CMS对用户程序影响变得很大。可能导致用户程序执行速度大幅降低。
  
  2：无法处理浮动垃圾 ：当在并发标记，用户线程继续运行，伴随着垃圾不断产生，但此部分垃圾处于标记结束后，CMS无法在当次清理掉，只能留待下一次垃圾收集清理。因为在垃圾收集过程中用户线程还在继续运行，所以不能等到老年代满了再对其收集，而要预留一部分空间供并发收集时程序使用。
  
  JDK6 老年代阈值92%将启动CMS：如果CS运行期间预留的内存无法满足程序分配新对象的需要，则会出现并发失败。
  
  虚拟机将启动后备预案：冻结用户线程执行： 启用Serial Old老年代垃圾收集
  
  所以-XX:CMSInitiatingOccuoanicuFraction设置的太高会导致大量并发失败产生，效率反而变低。
  
  3：空间碎片太多 --full GC
  
  CMS提供-XX:UseCMSCompactAtFullCollection开关，默认开启
  用于不得不进行fullGC是的碎片合并整理过程。这样会移动对象，无法并发。碎片问题可以解决，但停顿时间变长了。
  
  所以提供：-XX:CMSFullGCsBeforeCompaction 会在执行若干次full GC后进行碎片整理。
  
  
  

- Carbage First

  G1垃圾收集器  mixed GC模式
  
  标记整理
  
  不是Minor GC , 也不是 Major GC, 也不是 Full GC
  
  面向堆内存的任何部分来组成回收集 Collection Set CSet,衡量标准不再是哪个分代，而是哪块内存存放的垃圾数量最大，回收收益最大。
  
  G1提出了基于Region的堆内存布局。 不再坚持固定大小、数量分代区域划分，而是把java堆划分为多个大小相等的独立区域，每一个区域都可以根据需要，扮演新生代的Eden、Survivor或老年代空间。 收集器根据不同角色的Region采用不同的策略处理。
  
  Region中还有一类特殊的Humongous区域，专门存放大对象。超过Region容量一般的对象视为大对象。
  
  -XX:G1HeapRegionSize 设定 1Mb~32MB
  
  超过了整个Region的超级大对象，将会被存放在N个连续的Humongous Region 中。
  
  G1将Humongous Region作为老年代的一部分看待
  
  G1将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region的整数倍，这样可以有计划的避免在整个java堆中进行全区域的垃圾收集。
  
  让G1跟踪各个Region里面垃圾堆积的价值大小，维护一个优先级列表。每次根据用户允许的收集停顿时间，优先处理回收价值收益最大的哪些Region。 保证G1收集器在有限的时间内获取尽可能高的收集效率。
  
  如果不去计算用户线程运行过程中的动作。G1收集器运作过程大致可以分为四个步骤：
  
  1：初始标记 ：仅仅只是标记GCRoot直接关联到的对象
  
  2：并发标记：从GCRoot开始堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象。此阶段耗时较长，可与用户线程并发执行。当对象图扫描完成后，还要重新处理SATB记录下的在并发时有引用变动的对象。
  
  3：最终标记：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的那少量的SATB记录。
  
  4：筛选回收：更新Region的统计数据。对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间指定回收计划。可以选择任意多个Region构成回收集。然后把决定回收的那一部分Region的存活对象复制到空的Region中。再清理掉整个旧Region的全部空间。里面涉及到存活对象的移动，所以必须暂停用户线程。由多条收集器线程并行完成。
  
  可以由用户指定停顿时间。
  
  但如果我们把停顿时间条得非常低，可能出现由于停顿时间太短，导致每次选出来的回收集只占堆内存很小的一部分，收集的速度间件赶不上分配的速度，导致垃圾慢慢堆积，最终占满堆引发full GC反而降低性能。
  
  

### 低延迟垃圾收集器

- Shenandoah
- ZGC

### 垃圾收集器选择

### 内存分配回收策略

- 对象优先在Eden分配
- 大对象直接进入老年代
- 长期存活对象进入老年代
- 动态对象年龄判定
- 空间分配担保

## 虚拟机类加载机制

### 类加载时机

### 类加载过程

- 加载
- 验证
- 准备
- 解析
- 初始化

### 类加载器

- 类与类加载器
- 双亲委派机制
- 破坏双亲委派机制

### java模块化系统

