# JVM


除去网络、系统问题，java应用出问题。GC日志，java内存模型。


JDK 是一个核心库、开发工具、诊断工具的合集

java source code --jdk编译器javac---字节码文件 ----JIT编译器 C1/C2----机器码


源代码---AOT编译器---机器码




## java内存区域与内存溢出

### 运行时数据区域

- 程序计数器

  当前线程所执行字节码的行号指示器。
  
  字节码解释器就是通过改变这个计数器的值来选取下一跳执行的字节码指令。
  
  线程私有
  
  线程执行java方法，则计数器记录正在执行的虚拟机字节码指令地址。
  
  线程执行native方法，计数器值应为空。
  
  没有OutOfMemoryError
  
  改变计数器的值来确定执行的下一条指令，比如循环、分支、方法跳转、异常处理，线程恢复都是依赖程序计数器来完成。

  Java虚拟机多线程是通过线程轮流切换并分配处理器执行时间的方式实现的。为了线程切换能恢复到正确的位置，每条线程都需要一个独立的程序计数器，所以它是线程私有的。
  

- java虚拟机栈

  线程私有，生命周期与线程相同。
  
  虚拟机栈描述的时java方法执行的线程内存模型：每个方法被执行，虚拟机同步创建一个栈帧，
  用于存储
  
  局部变量表、操作数栈、动态链接、方法出口信息等。
  
  每一个方法被调用直至执行完毕过程，对应一个栈帧从虚拟机栈中从入栈到出栈的过程。
  
  局部变量表存放了编译器已知的各种 基本数据类型、对象引用等。
  
  线程请求的栈深度打羽虚拟机允许的深度：StackOverFlowError
  
  栈扩展时无法申请到足够的内存OutOfMemoryError
  
  
  

- 本地方法栈

  局部变量表 、 方法出口信息 操作数栈
  
  作用与虚拟机栈差不多
  
  但是是在调用本地方法时采用
  

- java堆

  线程共享区域 在虚拟机启动时创建
  
  此内存区域 存放对象实例   由垃圾回收器来管理内存
  
  可以固定大小，也可以时扩展的
  
  -Xmx -Xms
  
  若没有足够内存完成实例分配，并且堆无法扩展时
  
  OutOfMemoryError
  
  
  

- 方法区

  线程共享的区域
  
  用于存放 虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
  
  方法区为堆的一个逻辑部分。
  
  OutOfMemoryError
  
  运行时常量池是方法区的一部分。
  
  Class文件中，有类的版本、字段、方法、接口等描述信息外。还有常量池表，用于存放编译期产生的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
  
  
  

### 虚拟机对象创建

创建对象: new clone 反序列化

虚拟机收到一条字节码new指令后

首先检查此指令的参数能否在常量池中定位到一个类的符号引用
如果没有，则执行类加载过程。

类加载检查通过后，为新生对象分配内存。

对象所需内存大小在类加载完成后便可完全确定，为对象分配内存任务等同把一块确定大小的内存块从堆中划分出来。

假设java堆中内存是规整的，所有被使用过的内存都被放在一边，空闲的内存被放在一边，中间放着一个指针作为分界点的指示器。分配内存仅仅是把指针向空闲空间方向挪动一段与对象大小相等的距离。---指针碰撞

如果堆中内存不是规整的，虚拟机就必须维护一个列表，记录哪些内存块是可用的。在分配的时候从列表中找到一个足够大的。---空闲列表

Serial \ ParNew 标记整理 ----指针碰撞
CMS  标记清除---空闲列表




### OutOfMemoryError

## 垃圾收集器与内存分配

### 对象已死？

- 引用计数算法
- 可达性分析算法
- 引用

	- 强引用

		- 不会回收

	- 软引用

		- 非必须，内存泄漏时第二次回收

	- 弱引用

		- 生存到下一次垃圾收集

	- 虚引用

		- 收集时系统通知

- 回收方法区

### 垃圾收集算法

- 分代收集理论

	- 多数对象朝生夕灭，熬过多次垃圾收集对象更难消亡

		- Minor GC

			- 新生代垃圾收集

		- MajorGC

			- 老年代垃圾收集

		- MixedGC

			- G1收集器，new和old都收集

		- fullGC

			- 收集整个堆

- 标记-清除

	- 效率不稳定
	- 内存空间碎片化

- 标记-复制

	- 可用内存缩小到原来的一半

- 标记-整理

	- 需暂停用户线程  

### 经典垃圾收集器

![](../pics/t5.png)

- Serial

  单线程工作 -stop the world    串行复制算法
  
  新生代 复制算法/暂停所有用户线程
  
  老年代 标记-整理 / 暂停所有用户线程

  虚拟机运行在Client模式下默认新生代收集器
  
  

- ParNew

  多线程并行收集    多线程复制算法 
  
  并行 -- 同一时间多条垃圾收集线程协同工作、
  
  新生代 多条线程 复制算法/暂停所有用户线程
  
  老年代 标记-整理 / 暂停所有用户线程
  
  能和CMS老年代收集器配合使用
  
  CMS只能与 serial 和 ParNew配合
  
  ParNew并入CMS 
  
  单核心 Serial要胜于 ParNew
  
  -XX：ParallelGCThread 限制垃圾收集线程数
  

- Parallel Scavenge

  Parallel Scavenge收集器 新生代收集器  多线程复制算法--吞吐量

  CMS等收集器目标：缩短垃圾收集用户线程的停顿时间
  
  Parralel Scanvenge: 达到一个可控制的吞吐量
  
  吞吐量：用于运行用户代码的时间与处理器总消耗时间比值。
  
  缩短垃圾收集花费时间比例
  
  控制最大垃圾收集停顿时间:-XX:MaxGCPauseMillis
  
  吞吐量大小 ： -XX:GCTimeRatio
  
  

- Serial Old

  Serial 收集器老年版  单线程收集器
  
  和Parallel Scavenge 配合
  
  作为CMS失败后预案
  
  复制+标记整理
  

- Parallel Old

  Parallel Scavenge Old老年代版本   多线程并发标记整理
  
  标记-整理
  
  和 Parallel Scavenge 搭配使用
  
  适合吞吐量或处理器资源稀缺的场合
  

- CMS

  Concurrent Mark Sweep : 以获取最短回收停顿时间为目标的收集器。
  
  关注服务响应速度
  
  CMS基于标记-清除
  
  1：初始标记  2：并发标记  3：重新标记 4：并发清除
  
  初始标记 和 重新标记 需要stop the world
  
  初始标记：仅标记GC Root能直接关联的对象
  
  并发标记：从GC Root的直接关联对象开始遍历整个对象图，此过程耗时较长但不需要停顿用户线程。
  
  重新标记：修正并发标记期间，因为用户线程继续运作而导致标记产生的对象标记记录，停顿时间比初始标记长，但远小于并发标记。
  
  并发清除：删除标记阶段判断已经死亡的对象。由于不需要移动存活对象，此阶段可以与用户线程并发进行。
  
  缺点：
  1：占用一部分线程，降低总吞吐量。 CMS默认启动回收线程数为4. 当处理器核心多，则影响会小。当处理器核心不足四个。CMS对用户程序影响变得很大。可能导致用户程序执行速度大幅降低。
  
  2：无法处理浮动垃圾 ：当在并发标记，用户线程继续运行，伴随着垃圾不断产生，但此部分垃圾处于标记结束后，CMS无法在当次清理掉，只能留待下一次垃圾收集清理。因为在垃圾收集过程中用户线程还在继续运行，所以不能等到老年代满了再对其收集，而要预留一部分空间供并发收集时程序使用。

  
  JDK6 老年代阈值92%将启动CMS：如果CS运行期间预留的内存无法满足程序分配新对象的需要，则会出现并发失败。
  
  虚拟机将启动后备预案：冻结用户线程执行： 启用Serial Old老年代垃圾收集
  
  所以-XX:CMSInitiatingOccuoanicuFraction设置的太高会导致大量并发失败产生，效率反而变低。
  
  3：空间碎片太多 --full GC
  
  CMS提供-XX:UseCMSCompactAtFullCollection开关，默认开启
  用于不得不进行fullGC是的碎片合并整理过程。这样会移动对象，无法并发。碎片问题可以解决，但停顿时间变长了。
  
  所以提供：-XX:CMSFullGCsBeforeCompaction 会在执行若干次full GC后进行碎片整理。
  
  空间碎片过多，可能会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前出发FullGC。



- Carbage First

  G1垃圾收集器  mixed GC模式 或者 Young GC模式

  G1垃圾收集算法主要应用在多CPU大内存的服务中，在满足高吞吐量的同时，尽可能的满足垃圾回收时的暂停时间。
  
  标记整理
  
  不是Minor GC , 也不是 Major GC, 也不是 Full GC
  
  面向堆内存的任何部分来组成回收集 Collection Set CSet,衡量标准不再是哪个分代，而是哪块内存存放的垃圾数量最大，回收收益最大。
  
  G1提出了基于Region的堆内存布局。 不再坚持固定大小、数量分代区域划分，而是把java堆划分为多个大小相等的独立区域，每一个区域都可以根据需要，扮演新生代的Eden、Survivor或老年代空间。 收集器根据不同角色的Region采用不同的策略处理。

  每个Region被标记了E、S、O和H，这些区域在逻辑上被映射为Eden，Survivor和老年代。
  
  Region中还有一类特殊的Humongous区域，专门存放大对象。超过Region容量一般的对象视为大对象。
  
  -XX:G1HeapRegionSize 设定 1Mb~32MB
  
  超过了整个Region的超级大对象，将会被存放在N个连续的Humongous Region 中。
  
  G1将Humongous Region作为老年代的一部分看待
  
  G1将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region的整数倍，这样可以有计划的避免在整个java堆中进行全区域的垃圾收集。
  
  让G1跟踪各个Region里面垃圾堆积的价值大小，维护一个优先级列表。每次根据用户允许的收集停顿时间，优先处理回收价值收益最大的哪些Region。 保证G1收集器在有限的时间内获取尽可能高的收集效率。
  
  如果不去计算用户线程运行过程中的动作。G1收集器运作过程大致可以分为四个步骤：
  
  1：初始标记 ：仅仅只是标记GCRoot直接关联到的对象
  
  2：并发标记：从GCRoot开始堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象。此阶段耗时较长，可与用户线程并发执行。当对象图扫描完成后，还要重新处理SATB记录下的在并发时有引用变动的对象。
  
  3：最终标记：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的那少量的SATB记录。
  
  4：筛选回收：更新Region的统计数据。对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间指定回收计划。可以选择任意多个Region构成回收集。然后把决定回收的那一部分Region的存活对象复制到空的Region中。再清理掉整个旧Region的全部空间。里面涉及到存活对象的移动，所以必须暂停用户线程。由多条收集器线程并行完成。
  
  可以由用户指定停顿时间。
  
  但如果我们把停顿时间条得非常低，可能出现由于停顿时间太短，导致每次选出来的回收集只占堆内存很小的一部分，收集的速度间件赶不上分配的速度，导致垃圾慢慢堆积，最终占满堆引发full GC反而降低性能。
  
  

### 低延迟垃圾收集器

- Shenandoah
- ZGC

### 垃圾收集器选择

### 内存分配回收策略

- 对象优先在Eden分配
- 大对象直接进入老年代
- 长期存活对象进入老年代
- 动态对象年龄判定
- 空间分配担保

## 虚拟机类加载机制

### 类加载时机

不同语言的代码被编译成字节码文件，最终都需要加载到JVM中才能被运行和运用。

java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校检、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，此过程被称为虚拟机的类加载机制。

与那些在编译时需要进行连接的语言不同，在java语言中，类型的加载、连接和初始化都是在程序运行期间完成的。

---java语言运行期类加载的。

一个类型（类/接口）从被加载到虚拟机内存中开始，到卸载出内存为止，生命周期：加载、验证、准备、解析、初始化、使用、卸载 

验证 准备 解析 三个部分称为连接。

加载由虚拟机自行把握，但初始化规定有且只有六种情况需要立即对类进行初始化。 

new/java.lang.reflect反射/初始化父类/虚拟机启动初始化主类/...


### 类加载过程

- 加载

主要完成三件事情：

1：通过一个类的全限定名来获取定义此类的二进制字节流

2：将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构

3：在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

加载阶段结束后，java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区的数据存储格式由虚拟机自行定义。

类型数据安置在方法区之后，会在java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中类型数据的外部接口。


- 验证

验证的目的是确保Class文件的字节流中包含的信息符合jvm规范的全部约束要求，保证这些信息当作代码运行后不会危害虚拟机自身安全。

Class文件不一定只能由java源码编译而来，虚拟机需要检查输入的字节流，验证字节码是java虚拟机保护自身的必要措施。

验证阶段可以大致分为四个阶段： 文件格式验证、 元数据验证、 字节码验证、 符号引用验证

1：文件格式验证  是否以0xCAFEBABE开头 、 主次版本号 、 类型...

2：元数据验证  是否有父类 / 父类是否final / 是否抽象类  

3：字节码验证  通过数据流和控制流分析，确定语义是合法的，符合逻辑的。

4：符号引用验证： 该类是否缺少或者被禁止访问它依赖的某些外部类，方法，字段等资源。


- 准备

正式为类中定义的静态变量分配内存并设置类变量初始值的阶段。

变量所使用的内存都应当在方法区中分配，

方法区是一个逻辑的概念，类变量随着Class对象一起存放在java堆中。

此阶段进行内存分配的仅包括类变量，而不包括实例变量，实例变量会在对象实例化时随着对象一起分配在java堆中。

分配内存，分配初始值，要到类的初始化阶段才执行赋值语句。

static final 分配初始值将设定为指定值

- 解析

解析阶段时java虚拟机将常量池内的符号引用替换为直接引用的过程。

符号引用： 以一组符号来描述所引用的目标，符号可以时任何形式的字面量。

直接引用：可以直接指向目标的指针，相对偏移量或者是一个能间接定位到目标的句柄。

直接引用适合虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实力上翻译出来的直接引用可能不同。

类/接口解析 字段解析 方法解析


- 初始化

初始化阶段，java虚拟机才真正开始执行类中编写的java代码

在准备阶段，

初始化阶段就是执行类构造器<clinit>()方法的过程。

<clinit>()是java编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的

编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。

不用显式执行父类构造方法。

父类的<clinit>()方法先执行，父类定义的静态语句块要优先于子类变量赋值操作。

<clinit>()方法不是必须的，如果一个类没有静态语句块，也没有对变量的赋值操作，编译器可以不为这个类生成<clinit>()方法

接口中不能使用静态代码块，但仍有变量初始化的赋值操作，所以也会生成<clinit>()方法，但接口不用执行父类<clinit>()



### 类加载器

- 类与类加载器

java虚拟机将类加载阶段中”通过一个类的全限定名来获取描述该类的二进制字节流“放在java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。 实现这个动作的代码称为类加载器。

通过一个类的全限定名来获取描述该类的二进制字节流

类加载器用于实现类的加载动作。

对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类空间名称。



- 双亲委派机制

从虚拟机角度看，只存在两种类加载器

启动类加载器(Bootstrap ClassLoader)，这个类加载器由C++实现，是虚拟机自身的一部分。

其他所有类加载器，由java实现，独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader

jdk8及之前版本的java,绝大多数java程序都会使用一下3个系统提供的类加载器进行加载。

启动类加载器(Bootstrap Class Loader)

负责加载lib或其他指定目录下，能够被识别的类库加载到虚拟机的内存中。

启动类加载器无法被java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，直接使用null代替即可。




扩展类加载器(Extension Class Loader)

此加载器时再累sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。负责加载lib/ext目录中，或是被java.ext.dirs系统变量指定路径中所有的类库。

这是一种java系统类库的扩展机制，JDK的开发团队允许用户将具有通用性得类库放置在ext目录以扩展javaSE的的功能。

由于扩展类加载器时由Java代码实现的，开发者可以直接在程序中使用扩展类加载器加载Class文件。



应用程序类加载器(Application Class Loader)

这个类加载器由sun.misc.Launcher$AppClassLoader实现。

应用程序类加载器时ClassLoader类中的getSystemClassLoader()方法的返回值，也称系统加载器。

负责加载用户类路径上所有的类库，可以在代码中直接使用此类加载器。

如果应用程序中没有自定义过自己的类加载器，一般情况这个就是程序中默认的类加载器。 


java9之前的java应用都是由这三种类加载器互相配合完成加载的，还可以加入自定义的加载器进行扩展。

类加载器之间的层次关系被称为类加载器的双亲委派模型。

双亲委派模机制： 如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传给最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才尝试自己加载。

这种机制给java中的类具备了一种优先级的层次关系，因为Object类在程序的各种加载器环境中都能够保证是同一个类。

保证java程序运行稳定。 解决基础类型的一致性问题。


- 破坏双亲委派机制

第一次被破坏，在双亲委派模型之前，引入模型，兼容老的代码。

第二次破坏：模型自身缺陷，基础类型想要调回用户的代码。 JNDI服务 线程上下文类加载器

第三次破坏： 用户对程序动态性的追求， 代码热替换，代码热部署  --模块化




### 字节码格式

Java 虚拟机规范规定了 Java 虚拟机结构、Class 类文件结构、字节码指令等内容。

字节码文件结构是一组以 8 位字节为基础的二进制流。

在字节码结构中，有两种最基本的数据类型来表示字节码文件格式，分别是：无符号数和表。

无符号数属于最基本的数据类型

它以 u1、u2、u4、u8 六七分别代表 1 个字节、2 个字节、4 个字节、8 个字节的无符号数。

无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成的字符串值。

表是由多个无符号数或者其他表作为数据项构成的复合数据类型。

所有表都习惯性地以_info结尾。表用于描述有层次关系的复合结构的数据，例如下表第 5 行表示其实一个类型为 cp_info 的表（常量池），这里面存储了该类的所有常量。

![](..//pics/t1.png)

魔数与Class文件版本
常量池
访问标志
类索引、父类索引、接口索引
字段表集合
方法表集合
属性表集合


**魔数和Class文件版本**

魔数为了确认该文件为Class文件 4个字节的 0xCAFABABE    4个字节的版本号

5-6 minor version :次版本号 编译该 Class 文件的 JDK 次版本号。

7-8 majot version :主版本号 编译该 Class 文件的 JDK 主版本号。


**常量池**

常量池的常量都是由cp_info这种表结构组成的，而且表结构不同其大小也不同。在 Java 虚拟机规范中一共有 14 种 cp_info 类型的表结构。

![](../pics/t2.png)


cp_info表结构一共有三个字段,第一个字段表示这个表结构的标示值，第二、三个字段表示其表结构的描述，不同字段其意思不太一样

![](../pics/t3.png)



**u2访问标志**

在常量池结束之后，紧接着的两个字节代表类或接口的访问标记（access_flags）。  2个字节的访问标志。

这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口、是否定义为public类型、是否定义为abstract类型等。具体的标志位以及标志的含义见下表。


**u2类索引、父类索引、接口索引**

2个字节的类索引、2个字节的父类索引、2个字节的接口索引

类索引：用于确定这个类的全限定名类索引， 如00 05 表示其指向了常量池中第 5 个常量

父类索引：父类索引用于确定这个类的父类的全限定名，父类索引用一个u2类型的数据表示。

接口索引：接口索引集合就用来描述哪个类实现了哪些接口，这些被实现的接口将按 implements 语句（如果这个类本身就是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。

**u2字段表集合**

字段表集合用于描述接口或者类中声明的变量。

2个字节的字段表字段数量


字段表的每个字段用一个名为 field_info 的表来表示

![](../pics/t4.png)

**u2方法表集合**

u2:方法表方法数量

方法表中的每个方法都用一个 method_info 表示


**u2属性表集合**

2个字节：属性表属性数量 ，类属性


##GC




**什么时候执行full GC**
