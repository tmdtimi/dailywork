##NoSql

NotOnlySql

常用的SQL数据库是关系型数据库

Nosql种类：

![](../pics/c1.png)

单一数据库最大的好处在于事务性实现简单，由数据库自己保证。

举个简单的例子，下订单需要扣除一个库存，然后插入一条订单条目，如果库存和订单都是数据库表项的话这个事务是无懈可击的，如果库存在redis里，订单条目是MySQL，通常就需要先写redis，成功之后再写数据库，如果写数据库失败了还需要回滚redis，如果最后这个回滚因为网络之类的原因失败了，就会多扣一个库存。不要以为这些事情很好解决，事务性处理的复杂性远远超过你的想象，比如说还有写MySQL在提交的一瞬间连接断了这种情况，你都没法判断提交到底成功了还是失败了，那你的redis是回滚还是不回滚？


##CAP

分布式系统的最大难点，就是各个节点的状态如何保持一致。

CAP理论是在设计分布式系统的过程中，处理数据一致性问题时必须考虑的理论。

CAP即：Consistence  	Availability  partition tolerance

一致性  可用性  分区容错性

![](../pics/c2.png)

一个分布式系统，不可能同时做到这三点

一致性：更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致，这就是分布式的一致性。一致性的问题在并发系统中不可避免，对于客户端来说，一致性指的是并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。

可用性：服务一直可用，而且是正常响应时间。好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。

分区容忍性：分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务。

分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响。


对于一个分布式系统而言，P是前提，必须保证，因为只要有网络交互就一定会有延迟和数据丢失，这种状况我们必须接受，必须保证系统不能挂掉。


对于网络情况良好的分布式系统，CAP在大多时间能够同时满足C和A

![](../pics/c3.png)

假设一种极端情况，N1和N2之间的网络断开了，但我们仍要支持这种网络异常，也就是满足分区容错性，那么这样能不能同时满足一致性和可用性呢？

![](../pics/c4.png)

有二种选择

第一，牺牲数据一致性，响应旧的数据DB0给用户；

第二，牺牲可用性，阻塞等待，直到网络连接恢复，数据更新操作完成之后，再给用户响应最新的数据DB1。


##BASE

BASE是对CAP中 AP理论的延申，一致性和可用性权衡的结果，其来源于对大规模互联网分布式系统实践的总结，是基于CAP定律逐步演化而来。

核心思想是即使无法做到强一致性，但每个应用都可以根据自身业务特点，才用适当的方式来使系统打到最终一致性。

	也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。但保留最终一致性。


CAP在大多时间能够同时满足C和A。

AP方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。

在分区故障恢复后，系统应该达到最终一致性。这一点其实就是 BASE 理论延伸的地方。

BASE理论三要素：

1. basically available 基本可用


2. soft-state 软状态


3. Eventually consistent 最终一致性


1：基本可用

基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。

允许损失部分可用性：

1. 响应时间上的损失: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。
2. 系统功能上的损失：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。


2：软状态
软状态指允许系统中的数据存在中间状态（CAP 理论中的数据不一致），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。

3：最终一致性

最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。


一致性三种级别：


1. 强一致性 ：系统写入了什么，读出来的就是什么。

2. 弱一致性 ：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。

3. 最终一致性 ：弱一致性的升级版。系统会保证在一定时间内达到数据一致的状态，


##Redis简介

**背景**

Redis是C语言开发的一个开源的（遵从BSD协议）高性能键值对（key-value）的内存数据库，可以用作**数据库**、**缓存**、**消息中间件等**。它是一种NoSQL（not-only sql，泛指非关系型数据库）的数据库。

Redis作为一个内存数据库。

1、性能优秀，数据在内存中，读写速度非常快，支持并发10W QPS；

2、单进程单线程，是线程安全的，采用IO多路复用机制；

3、丰富的数据类型，支持字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等；

4、支持数据持久化。可以将内存中数据保存在磁盘中，重启时加载；

5、主从复制，哨兵，高可用；

6、可以用作分布式锁；

7、可以作为消息中间件使用，支持发布订阅


redis默认有16个数据库，可以使用select进行切换。

基本操作 

select 3 / flush all / keys * / set name wubo / get name / flushdb / FLUSHALL / EXISTS key / move name 1

EXPIRE name seconds / ttl name / type name / 




**Redis为什么快**

多线程的目的，就是通过并发的方式来提升I/O的利用率和CPU的利用率。

而Redis的操作基本都是基于内存的，CPU资源根本就不是Redis的性能瓶颈。

Redis的瓶颈是机器的内存和网络带宽。

redis是单线程的，省去了很多上下文切换线程的时间；

在进行一些复杂结构的细粒度的操作，由于是单线程，所以不需要考虑锁的问题。不存在加锁释放锁死锁等操作导致的性能消耗。

redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。

Redis使用的是非阻塞IO，IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。

数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。

单线程 ： Redis网络IO和键值对读写是由一个线程完成的，而其他的如持久化存储模块、集群支撑模块等是多线程的。



### IO多路复用 ###

多进程并发模型：每进来一个新的IO流会分配一个新的进程管理。

IO多路复用：单个线程，通过记录每个IO的状态，同时管理多个IO流。

![](../pics/IO1.png)

I/O multiplexing 这里面的 multiplexing 指的其实是在单个线程通过记录跟踪每一个Sock(I/O流)的状态(对应空管塔里面的Fight progress strip槽)来同时管理多个I/O流. 发明它的原因，是尽量多的提高服务器的吞吐能力。

单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力。

应用程序通常需要处理来自多条事件流中的事件，比如我现在用的电脑，需要同时处理键盘鼠标的输入、中断信号等等事件，再比如web服务器如nginx，需要同时处理来来自N个客户端的事件。

CPU单核在同一时刻只能做一件事情，一种解决办法是对CPU进行时分复用(多个事件流将CPU切割成多个时间片，不同事件流的时间片交替进行)。。。

在计算机系统中，我们用线程或者进程来表示一条执行流，通过不同的线程或进程在操作系统内部的调度，来做到对CPU处理的时分复用。这样多个事件流就可以并发进行，不需要一个等待另一个太久，在用户看起来他们似乎就是并行在做一样。

但凡事都是有成本的。线程/进程也一样，有这么几个方面：

1：线程/进程创建成本

2：CPU切换不同线程/进程的成本

3：多线程的资源竞争

在单线程中处理多个事件流的方法 ---- IO多路复用。

Linux下的IO模型 ： 阻塞IO / 非阻塞IO / IO多路复用 / 信号驱动IO / 异步IO

阻塞IO：阻塞IO意味着当我们发起一次IO操作后一直等待成功或失败之后才返回，在这期间程序不能做其它的事情。阻塞IO操作只能对单个文件描述符进行操作，详见read或write。

非阻塞IO：我们在发起IO时，通过对文件描述符设置O_NONBLOCK flag来指定该文件描述符的IO操作为非阻塞。非阻塞IO通常发生在一个for循环当中，因为每次进行IO操作时要么IO操作成功，要么当IO操作会阻塞时返回错误EWOULDBLOCK/EAGAIN，然后再根据需要进行下一次的for循环操作，这种类似轮询的方式会浪费很多不必要的CPU资源，是一种糟糕的设计。和阻塞IO一样，非阻塞IO也是通过调用read或write来进行操作的，也只能对单个描述符进行操作。

IO多路复用：单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力。

信号驱动IO：信号驱动IO是利用信号机制，让内核告知应用程序文件描述符的相关事件。

异步IO：相比信号驱动IO需要在程序中完成数据从用户态到内核态(或反方向)的拷贝，异步IO可以把拷贝这一步也帮我们完成之后才通知应用程序。我们使用 aio_read 来读，aio_write 写。

同步IO指的是程序会一直阻塞到IO操作如read、write完成 2. 异步IO指的是IO操作不会阻塞当前程序的继续执行

![](../pics/epoll.png)





##五大基本数据类型

![](../pics/c5.png)


###String
String 是Redis的最基本的数据类型，可以理解为与 Memcached 一模一样的类型，一个key 对应一个 value。string 类型是二进制安全的，意思是 Redis 的 string 可以包含任何数据，比如图片或者序列化的对象，一个 redis 中字符串 value 最多可以是 512M。

APPEND key1 hello (key1不存在相当于set)/ STRLEN key1 / 

set view 0 / incr view (+1) / decr view (-1) / INCRBY view 10 (+10) / DECRBY view 10 (-10)

GETRANGE key 1 3 / GETRANGE key 0 -1 (查看全部) / SETRANGE key 1 xx / 

setex key second value (set with expire 设置过期时间) / setnx key "value"    (set if not exit 不存在再设置)

mset k1 v1 k2 v2 k3 v3 / mget k1 k2 k3 / msetnx k1 v1 k2 v2 (要么一起成功，要么一起失败)

set user:1 {name:wubo,age:25} （设置一个对象） / mset user:1:name wu user:1:age 18 / mget user:1:name user:1:age

user:id {filed}

getset name wu  (如果不存在返回null . 如果存在 先返回旧值 再设置新值) 

redis:计数器  对象缓存

###List
###Set
###Hash
###Zset
##三种特殊数据类型
###geo
###hyperloglog
###bitmap
##配置详解
##Redis持久化
###RDB
###AOF
##事务操作
##订阅发布
##主从复制
##哨兵模式
##缓存穿透
##缓存击穿
##缓存雪崩
