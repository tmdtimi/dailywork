##缓存


![Alt pic](https://github.com/tmdtimi/dailywork/blob/main/chapter/%E7%BC%93%E5%AD%98/pics/a4.png)


使用空间换时间 -- 二八定律：80%的数据访问集中在20%的数据上

缓存一般使用内存作为存储，内存读写快于硬盘。

### 1：缓存分类

1. 本地缓存

	使用进程类的成员变量或静态变量 可以直接使用语言标准库中的容器来存储 如Map
	


2. 分布式缓存

	当缓存的数据量增大时，单机不足以承担缓存服务时，就要考虑对缓存进行水平扩展。引入缓存集群。
	
	将数据分片分散储存在不同的机器

	决定每个数据分片放在哪台机器---一致性hash算法 

	它能够保证在缓存集群动态调整，不断增加或者减少机器后，客户端访问时依然能够根据 key 访问到数据。

	常用的组件 -Redis MemCached Redis Cluster


### 2：缓存使用

1. 缓存适用场景
	
	读多写少： 如电商里的商品详情页面，访问频率很高，但是一般写入只在店家上架商品和修改信息的时候发生。把热点商品的信息缓存起来，这将拦截掉很多对数据库的访问，提高系统整体的吞吐量。
	
	一般数据库的 QPS 由于有「ACID」约束、并且数据是持久化在硬盘的，所以比 Redis 这类基于内存的 NoSQL 存储低不少。常常是一个系统的瓶颈，如果我们把大部分的查询都在 Redis 缓存中命中了，那么系统整体的 QPS 也就上去了。

	计算耗时大，且实时性不高： 比如王者荣耀里的全区排行榜，一般一周更新一次，并且计算的数据量也比较大，所以计算后缓存起来，请求排行榜直接从缓存中取出，就不用实时计算了


2. 缓存不适用场景
	
	写多读少，频繁更新。

	对数据一致性要求严格： 因为缓存会有更新策略，所以很难做到和数据库实时同步。

	数据访问完全随机： 因为这样会导致缓存的命中率极低。


### 2：缓存更新策略

**Cache-Aside Cache-AS-SOR**

1. Cache-Aside


![Alt pic](../pics/a2.png)

	
读数据，先从缓存读，如果cache hit直接返回，没命中则从数据源获取，并更新缓存
	
写数据，先更新数据源，然后删除该缓存，下一次读此数据必然cache miss,然后触发回源。


![Alt pic](https://github.com/tmdtimi/dailywork/blob/main/chapter/%E7%BC%93%E5%AD%98/pics/a1.png)

缺点：

首次请求的数据一定不在Cache中

写操作比较频繁时，Cache中的数据被频繁删除，影响缓存命中率。

可能数据不一致


2. Cache-AS-SOR



	将Cache作为数据源	，一切读写都是针对Cache的，由**Cache内部维护自己和数据源的一致性。**
	
	分为三个方式
	
	1. Read Through

	查询时发生 cache miss 去更新缓存，但是区别在于 Cache-Aside 需要调用方手动更新缓存，而 Cache-As-SoR 则是由缓存内部实现自己负责，对应用层透明。

	2. Write Through

	直写式，就是在将数据写入缓存的同时，缓存也去更新后面的数据源，并且必须等到数据源被更新成功后才可返回。这样保证了缓存和数据库里的数据一致性。

	3. Write Back

	回写式，数据写入缓存即可返回，缓存内部会异步的去更新数据源，这样好处是写操作特别快，因为只需要更新缓存。并且缓存内部可以合并对相同数据项的多次更新，但是带来的问题就是数据不一致，可能发生写丢失。

![Alt pic](https://github.com/tmdtimi/dailywork/blob/main/chapter/%E7%BC%93%E5%AD%98/pics/a3.png)
	
### 缓存雪崩	

缓存雪崩指的是在某一个时刻大流量怼到系统， 这时候系统出现了大量的 key同时失效， 这样导致了大量的请求到了数据库层， 导致数据库奔溃从而导致整个系统雪崩的现象。

解决方案：
过期时间加上随机数，减少key在同一时间大量失效的情况

### 缓存穿透	

缓存穿透更多的是一种恶意访问， 黑客故意大量访问一个 redis 里面没有，数据库也没有的数据，这样同样会导致大量请求落到数据库，所以访问数据库加锁是必要的。 但是这里又有一个问题， 恶意访问会占用 redis 的连接资源， 所以这里需要使用拦截手段，把请求拦截在 redis 之外，比如用布隆过滤器，比如用本地缓存都可以有效拦截对 redis 的恶意访问。

解决方案：

1、使用布隆过滤器提前拦截

2、如果是 redis 没有， 数据库也没有的情况， 可以把一个 null 字符串存储到 redis 并且存一份到本地缓存， 存本地缓存的目的也是为了减少对redis 的访问压力。


### 缓存击穿	

在某一个时刻大并发下请求某一个 key， 而这个 key 恰好在这个时候失效了， 这时候大量的请求会怼到数据库从而导致系统奔溃。解决方案： 

缓存要做预热，且缓存的失效时间要大于业务生命周期时间，比如一个秒杀业务 1 小时内秒完， 那么这个 key 的失效时间要大于 1 小时。

请求数据库的逻辑需要加锁， 避免大量请求落到数据库层。 可能这个锁的逻辑块永远不会执行， 因为缓存是存在在 redis 的， 但是代码要有健壮性考虑。
