mysql 如何利用索引优化查询速度：

![图片](https://uploader.shimo.im/f/Tdkj2VkcoKB6SJCG.png!thumbnail)

磁盘IO通过机械运动读取数据，每一次读取数据需要 ：  寻道 、 寻点 、 拷贝到内存

寻道时间是磁臂移动到指定磁道所需要的时间，一般在5ms以下；

寻点是从磁道中找到数据存在的那个点，平均时间是半圈时间，如果是一个7200转/min的磁盘，寻点时间平均是600000/7200/2=4.17ms；

拷贝到内存的时间很快，和前面两个时间比起来可以忽略不计，所以一次IO的时间平均是在9ms左右。听起来很快，但数据库百万级别的数据过一遍就达到了9000s，显然就是灾难级别的了。

计算机操作系统做了预读的优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。

每一次IO读取的数据我们称之为一页(page)，具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO。

要优化数据库查询，就要尽量减少磁盘的IO操作，所以就出现了索引。

# 

# 为什么需要索引

减少程序运行时间 提高效率

其实程序在内存里处理数据  cpu的计算是很快的 效率很高

但是IO操作 因为它要通过机械运动 需要在 磁盘上面 寻道 寻点 拷贝到内存

所以相对会花很多时间

所以 在编码的时候 会尽量读写次数,减少IO 操作

-->建立索引

索引是对IO操作的优化

它利用一些数据结构 对数据进行排序  让我们能够很快的在数据库里找到数据

# 索引的类型

索引包括：聚集索引 、 覆盖索引 、组合索引 、 前缀索引 、 唯一索引 等

默认都是使用 B+树 作为数据结构

主键索引： 索引中的值必须是唯一的，不允许有空值

普通索引： MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。

唯一索引： 索引中的值必须是唯一的。但是允许为空

全文索引： 只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引。MyISAM和InnoDB中都可以使用全文索引。

空间索引： 没用过 。好像在索引上加了OpenGIS几何数据模型的规则

前缀索引： 在文本类型如CHAR,VARCHAR,TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定。

单列索引

组合索引： 最左前缀匹配原则

# 索引数据结构

HASH表： key-value型 等值查询O(1)  范围查询--全表扫描

Hash表在等值查询时效率很高，时间复杂度为O(1)；但是不支持范围快速查找，范围查找时还是只能通过扫描全表方式。

二叉查找树 ： 可以通过折半查找来减少IO次数--但是123456 退化成链表了 IO次数近乎于遍历

平衡二叉数：

树的两个子树的层级 最多相差1

在插入删除数据时通过左旋/右旋操作保持二叉树的平衡，不会出现左子树很高、右子树很矮的情况。

所以查找接近于二分查找 O(log n)

对每个节点的读取就相当于一次IO

所以时间复杂度 和树的高度有关  表数据多的时候 性能差

而且不支持范围查询

B树： 多叉平衡查找树--降低平衡树的高度-->减少磁盘的IO操作

一个节点存储多个元素，每个内节点多个分叉

节点中的元素包括键值和数据，根据键值来进行排序

所有 叶子节点有相同的高度  叶子节点之间没有指针连接

![图片](https://uploader.shimo.im/f/A3SaTrvgq1SwvckL.png!thumbnail)

比较的次数并没有减少，但是比较是在内存中进行的，very fast

IO的次数就大大的减少了。缺点：

不支持范围查询 。 想范围查询又得从根节点开始比 麻烦

数据放在节点里 ， 每次IO读取的数据是有限的 ， IO次数增加

B+树：

把B树优化了，只有叶子节点存数据，叶子节点间有指针 支持快速范围查

其他节点不存数据 ，磁盘块存的索引更多了，树更矮了，IO更少了

InnoDB的叶子节点Data存的是行记录

MyIsam的叶子节点Data存的是磁盘地址

# 

# MyISAM索引和InnoDB索引

MyIsam索引：

MyISAM的数据文件和索引文件是分开存储的。MyISAM使用B+树构建索引树时，叶子节点中存储的键值为索引列的值，数据为索引所在行的磁盘地址。

![图片](https://uploader.shimo.im/f/NgyF6A5hOPep1r9T.png!thumbnail)建了个表 ： 一个id为主键索引  一个age为普通索引

![图片](https://uploader.shimo.im/f/QR1JpTcE7jEQGeXw.png!thumbnail)主键等值查询：

select * from user where id = 28;

索引在 user.MYI文件中  数据在user.MYD中

![图片](https://uploader.shimo.im/f/790MSd4GDp3xwewy.png!thumbnail)

磁盘IO次数： 3次索引检索+记录数据检索。根据主键范围查询数据：

select * from user where id between 28 and 47;

![图片](https://uploader.shimo.im/f/I72cDQXXEBVJxSqP.png!thumbnail)磁盘IO次数： 4次索引检索+记录数据检索。

tag:MyISAM在查询时，会将索引节点缓存在MySQL缓存中，而数据缓存依赖于操作系统自身的缓存，所以并不是每次都是走的磁盘，这里只是为了分析索引的使用过程。辅助索引：

在 MyISAM 中,辅助索引和主键索引的结构是一样的，没有任何区别，叶子节点的数据存储的都是行记录的磁盘地址。只是主键索引的键值是唯一的，而辅助索引的键值可以重复。

查询数据时，由于辅助索引的键值不唯一，可能存在多个拥有相同的记录，所以即使是等值查询，也需要按照范围查询的方式在辅助索引树中检索数据。InnoDB索引:

主键索引（聚集索引） --行数据就在叶子节点

每个InnoDB表都有一个聚簇索引 ，聚簇索引使用B+树构建，叶子节点存储的数据是整行记录。一般情况下，聚簇索引等同于主键索引。

当一个表没有创建主键索引时，InnoDB会自动创建一个ROWID字段来构建聚簇索引创建索引的规则：

在表上定义主键PRIMARY KEY，InnoDB将主键索引用作聚簇索引。

如果表没有定义主键，InnoDB会选择第一个不为NULL的唯一索引列用作聚簇索引。

如果以上两个都没有，InnoDB 会使用一个6 字节长整型的隐式字段 ROWID字段构建聚簇索引。该ROWID字段会在插入新行时自动递增。辅助索引：

除聚簇索引之外的所有索引都称为辅助索引。在中InnoDB，辅助索引中的叶子节点存储的数据是该行的主键值对。在检索时，InnoDB使用此主键值在聚簇索引中搜索行记录。建个表：

![图片](https://uploader.shimo.im/f/RQT2EeJ2J8umfVnj.png!thumbnail)

InnoDB的数据和索引存储在一个文件t_user_innodb.ibd

主键索引的叶子节点会存储数据行，辅助索引只会存储主键值。

![图片](https://uploader.shimo.im/f/5c99Sk7IEwUaRGtp.png!thumbnail)等值查询数据：

select * from user_innodb where id = 28;

![图片](https://uploader.shimo.im/f/WAF7Qw0upVgTDY0c.png!thumbnail)

辅助索引查询数据： ID为主键索引值  age从小到大

![图片](https://uploader.shimo.im/f/6TDVnLkVULAPZ6vd.png!thumbnail)使用辅助索引需要检索两遍索引：

首先检索辅助索引获得主键

然后使用主键到主索引中检索获得记录

select * from t_user_innodb where age=19;

![图片](https://uploader.shimo.im/f/0nQCDjSjUkWefpaU.png!thumbnail)

磁盘IO次数：辅助索引3次+获取记录回表3次组合索引：

建个表：

![图片](https://uploader.shimo.im/f/rt410TEEABqoz2EY.png!thumbnail)

![图片](https://uploader.shimo.im/f/0NBBA4n9D67tEjsb.png!thumbnail)组合索引的查询：

select * from abc_innodb where a = 13 and b = 16 and c = 4;

![图片](https://uploader.shimo.im/f/ZOiII6RHEAm34s6v.png!thumbnail)

组合索引的最左匹配原则：

在组合索引树中，最底层的叶子节点按照第一列a列从左到右递增排列，但是b列和c列是无序的，b列只有在a列值相等的情况下小范围内递增有序，而c列只能在a，b两列相等的情况下小范围内递增有序。B+树会先比较a列来确定下一步应该搜索的方向，往左还是往右。如果a列相同再比较b列。但是如果查询条件没有a列，B+树就不知道第一步应该从哪个节点查起。可以说创建的idx_abc(a,b,c)索引，相当于创建了(a)、（a,b）（a,b,c）三个索引组合索引的最左前缀匹配原则：使用组合索引查询时，mysql会一直向右匹配直至遇到范围查询(>、<、between、like)就停止匹配覆盖索引：

覆盖索引并不是说是索引结构，覆盖索引是一种很常用的优化手段。因为在使用辅助索引的时候，我们只可以拿到主键值，相当于获取数据还需要再根据主键查询主键索引再获取到数据。但是试想下这么一种情况，在上面abc_innodb表中的组合索引查询时，如果我只需要abc字段的，那是不是意味着我们查询到组合索引的叶子节点就可以直接返回了，而不需要回表。这种情况就是覆盖索引。

# 索引弊端：

时间、空间、维护成本

* 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
* 除了数据表占数据空间之外，每一个索引还要占一定的物理空间。如果要建立聚簇索引，那么需要的空间就会更大。
* 当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。

索引可以在一些情况下加速查询，但是在某些情况下，会降低效率。

索引只是提高效率的一个因素，因此在建立索引的时候应该遵循以下原则：

* 在经常需要搜索的列上建立索引，可以加快搜索的速度。
* 在作为主键的列上创建索引，强制该列的唯一性，并组织表中数据的排列结构。
* 在经常使用表连接的列上创建索引，这些列主要是一些外键，可以加快表连接的速度。
* 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，所以其指定的范围是连续的。
* 在经常需要排序的列上创建索引，因为索引已经排序，所以查询时可以利用索引的排序，加快排序查询。
* 在经常使用 WHERE 子句的列上创建索引，加快条件的判断速度。



